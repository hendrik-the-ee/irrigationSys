"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.ARGS_SET = undefined;
exports.setDestroying = setDestroying;
exports.setDestroyed = setDestroyed;

var _env = require("@glimmer/env");

var _owner = require("./owner");

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var DESTROYING = new WeakMap();
var DESTROYED = new WeakMap();

function setDestroying(component) {
  DESTROYING.set(component, true);
}

function setDestroyed(component) {
  DESTROYED.set(component, true);
}

var ARGS_SET = exports.ARGS_SET = undefined;

if (_env.DEBUG) {
  exports.ARGS_SET = ARGS_SET = new WeakMap();
}
/**
 * The `Component` class defines an encapsulated UI element that is rendered to
 * the DOM. A component is made up of a template and, optionally, this component
 * object.
 *
 * ## Defining a Component
 *
 * To define a component, subclass `Component` and add your own properties,
 * methods and lifecycle hooks:
 *
 * ```ts
 * import Component from '@glimmer/component';
 *
 * export default class extends Component {
 * }
 * ```
 *
 * ## Lifecycle Hooks
 *
 * Lifecycle hooks allow you to respond to changes to a component, such as when
 * it gets created, rendered, updated or destroyed. To add a lifecycle hook to a
 * component, implement the hook as a method on your component subclass.
 *
 * For example, to be notified when Glimmer has rendered your component so you
 * can attach a legacy jQuery plugin, implement the `didInsertElement()` method:
 *
 * ```ts
 * import Component from '@glimmer/component';
 *
 * export default class extends Component {
 *   didInsertElement() {
 *     $(this.element).pickadate();
 *   }
 * }
 * ```
 *
 * ## Data for Templates
 *
 * `Component`s have two different kinds of data, or state, that can be
 * displayed in templates:
 *
 * 1. Arguments
 * 2. Properties
 *
 * Arguments are data that is passed in to a component from its parent
 * component. For example, if I have a `UserGreeting` component, I can pass it
 * a name and greeting to use:
 *
 * ```hbs
 * <UserGreeting @name="Ricardo" @greeting="Olá" />
 * ```
 *
 * Inside my `UserGreeting` template, I can access the `@name` and `@greeting`
 * arguments that I've been given:
 *
 * ```hbs
 * {{@greeting}}, {{@name}}!
 * ```
 *
 * Arguments are also available inside my component:
 *
 * ```ts
 * console.log(this.args.greeting); // prints "Olá"
 * ```
 *
 * Properties, on the other hand, are internal to the component and declared in
 * the class. You can use properties to store data that you want to show in the
 * template, or pass to another component as an argument.
 *
 * ```ts
 * import Component from '@glimmer/component';
 *
 * export default class extends Component {
 *   user = {
 *     name: 'Robbie'
 *   }
 * }
 * ```
 *
 * In the above example, we've defined a component with a `user` property that
 * contains an object with its own `name` property.
 *
 * We can render that property in our template:
 *
 * ```hbs
 * Hello, {{user.name}}!
 * ```
 *
 * We can also take that property and pass it as an argument to the
 * `UserGreeting` component we defined above:
 *
 * ```hbs
 * <UserGreeting @greeting="Hello" @name={{user.name}} />
 * ```
 *
 * ## Arguments vs. Properties
 *
 * Remember, arguments are data that was given to your component by its parent
 * component, and properties are data your component has defined for itself.
 *
 * You can tell the difference between arguments and properties in templates
 * because arguments always start with an `@` sign (think "A is for arguments"):
 *
 * ```hbs
 * {{@firstName}}
 * ```
 *
 * We know that `@firstName` came from the parent component, not the current
 * component, because it starts with `@` and is therefore an argument.
 *
 * On the other hand, if we see:
 *
 * ```hbs
 * {{name}}
 * ```
 *
 * We know that `name` is a property on the component. If we want to know where
 * the data is coming from, we can go look at our component class to find out.
 *
 * Inside the component itself, arguments always show up inside the component's
 * `args` property. For example, if `{{@firstName}}` is `Tom` in the template,
 * inside the component `this.args.firstName` would also be `Tom`.
 */


var BaseComponent =
/*#__PURE__*/
function () {
  /**
   * Constructs a new component and assigns itself the passed properties. You
   * should not construct new components yourself. Instead, Glimmer will
   * instantiate new components automatically as it renders.
   *
   * @param owner
   * @param args
   */
  function BaseComponent(owner, args) {
    if (_env.DEBUG && !(owner !== null && typeof owner === 'object' && ARGS_SET.has(args))) {
      throw new Error("You must pass both the owner and args to super() in your component: " + this.constructor.name + ". You can pass them directly, or use ...arguments to pass all arguments through.");
    }

    this.args = args;
    (0, _owner.setOwner)(this, owner);
    DESTROYING.set(this, false);
    DESTROYED.set(this, false);
  }

  var _proto = BaseComponent.prototype;
  /**
   * Called before the component has been removed from the DOM.
   */

  _proto.willDestroy = function willDestroy() {};

  _createClass(BaseComponent, [{
    key: "isDestroying",
    get: function get() {
      return DESTROYING.get(this);
    }
  }, {
    key: "isDestroyed",
    get: function get() {
      return DESTROYED.get(this);
    }
  }]);

  return BaseComponent;
}();

exports.default = BaseComponent;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL2NvbXBvbmVudC9hZGRvbi8tcHJpdmF0ZS9jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O1FBTU0sYSxHQUFBLGE7UUFHQSxZLEdBQUEsWTs7QUFUTjs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUEsSUFBTSxVQUFVLEdBQUcsSUFBbkIsT0FBbUIsRUFBbkI7QUFDQSxJQUFNLFNBQVMsR0FBRyxJQUFsQixPQUFrQixFQUFsQjs7QUFFTSxTQUFBLGFBQUEsQ0FBQSxTQUFBLEVBQXlEO0FBQzdELEVBQUEsVUFBVSxDQUFWLEdBQUEsQ0FBQSxTQUFBLEVBQUEsSUFBQTtBQUNEOztBQUNLLFNBQUEsWUFBQSxDQUFBLFNBQUEsRUFBd0Q7QUFDNUQsRUFBQSxTQUFTLENBQVQsR0FBQSxDQUFBLFNBQUEsRUFBQSxJQUFBO0FBQ0Q7O0FBRU0sSUFBSSxRQUFKLFdBQUksUUFBSixZQUFBOztBQUVQLElBQUEsVUFBQSxFQUFXO0FBQ1QsVUFIUyxRQUdULEdBQUEsUUFBUSxHQUFHLElBQVgsT0FBVyxFQUFYO0FBQ0Q7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUEySHFCLGE7OztBQUNuQjs7Ozs7Ozs7QUFRQSxXQUFBLGFBQUEsQ0FBQSxLQUFBLEVBQUEsSUFBQSxFQUFtQztBQUNqQyxRQUFJLGNBQVMsRUFBRSxLQUFLLEtBQUwsSUFBQSxJQUFrQixPQUFBLEtBQUEsS0FBbEIsUUFBQSxJQUErQyxRQUFRLENBQVIsR0FBQSxDQUE5RCxJQUE4RCxDQUFqRCxDQUFiLEVBQW1GO0FBQ2pGLFlBQU0sSUFBQSxLQUFBLENBQUEseUVBRUYsS0FBQSxXQUFBLENBRkUsSUFBQSxHQUFOLGtGQUFNLENBQU47QUFLRDs7QUFFRCxTQUFBLElBQUEsR0FBQSxJQUFBO0FBQ0EseUJBQVEsSUFBUixFQUFBLEtBQUE7QUFFQSxJQUFBLFVBQVUsQ0FBVixHQUFBLENBQUEsSUFBQSxFQUFBLEtBQUE7QUFDQSxJQUFBLFNBQVMsQ0FBVCxHQUFBLENBQUEsSUFBQSxFQUFBLEtBQUE7QUFDRDs7O0FBb0NEOzs7O1NBR0EsVyxHQUFBLFNBQUEsV0FBQSxHQUFXLEM7Ozs7d0JBWEs7QUFDZCxhQUFPLFVBQVUsQ0FBVixHQUFBLENBQVAsSUFBTyxDQUFQO0FBQ0Q7Ozt3QkFFYztBQUNiLGFBQU8sU0FBUyxDQUFULEdBQUEsQ0FBUCxJQUFPLENBQVA7QUFDRDs7Ozs7O2tCQXpEa0IsYSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERFQlVHIH0gZnJvbSAnQGdsaW1tZXIvZW52JztcbmltcG9ydCB7IHNldE93bmVyIH0gZnJvbSAnLi9vd25lcic7XG5cbmNvbnN0IERFU1RST1lJTkcgPSBuZXcgV2Vha01hcDxCYXNlQ29tcG9uZW50PHVua25vd24+LCBib29sZWFuPigpO1xuY29uc3QgREVTVFJPWUVEID0gbmV3IFdlYWtNYXA8QmFzZUNvbXBvbmVudDx1bmtub3duPiwgYm9vbGVhbj4oKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHNldERlc3Ryb3lpbmcoY29tcG9uZW50OiBCYXNlQ29tcG9uZW50PHVua25vd24+KSB7XG4gIERFU1RST1lJTkcuc2V0KGNvbXBvbmVudCwgdHJ1ZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gc2V0RGVzdHJveWVkKGNvbXBvbmVudDogQmFzZUNvbXBvbmVudDx1bmtub3duPikge1xuICBERVNUUk9ZRUQuc2V0KGNvbXBvbmVudCwgdHJ1ZSk7XG59XG5cbmV4cG9ydCBsZXQgQVJHU19TRVQ6IFdlYWtNYXA8YW55LCBib29sZWFuPjtcblxuaWYgKERFQlVHKSB7XG4gIEFSR1NfU0VUID0gbmV3IFdlYWtNYXAoKTtcbn1cblxuLyoqXG4gKiBUaGUgYENvbXBvbmVudGAgY2xhc3MgZGVmaW5lcyBhbiBlbmNhcHN1bGF0ZWQgVUkgZWxlbWVudCB0aGF0IGlzIHJlbmRlcmVkIHRvXG4gKiB0aGUgRE9NLiBBIGNvbXBvbmVudCBpcyBtYWRlIHVwIG9mIGEgdGVtcGxhdGUgYW5kLCBvcHRpb25hbGx5LCB0aGlzIGNvbXBvbmVudFxuICogb2JqZWN0LlxuICpcbiAqICMjIERlZmluaW5nIGEgQ29tcG9uZW50XG4gKlxuICogVG8gZGVmaW5lIGEgY29tcG9uZW50LCBzdWJjbGFzcyBgQ29tcG9uZW50YCBhbmQgYWRkIHlvdXIgb3duIHByb3BlcnRpZXMsXG4gKiBtZXRob2RzIGFuZCBsaWZlY3ljbGUgaG9va3M6XG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCBDb21wb25lbnQgZnJvbSAnQGdsaW1tZXIvY29tcG9uZW50JztcbiAqXG4gKiBleHBvcnQgZGVmYXVsdCBjbGFzcyBleHRlbmRzIENvbXBvbmVudCB7XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiAjIyBMaWZlY3ljbGUgSG9va3NcbiAqXG4gKiBMaWZlY3ljbGUgaG9va3MgYWxsb3cgeW91IHRvIHJlc3BvbmQgdG8gY2hhbmdlcyB0byBhIGNvbXBvbmVudCwgc3VjaCBhcyB3aGVuXG4gKiBpdCBnZXRzIGNyZWF0ZWQsIHJlbmRlcmVkLCB1cGRhdGVkIG9yIGRlc3Ryb3llZC4gVG8gYWRkIGEgbGlmZWN5Y2xlIGhvb2sgdG8gYVxuICogY29tcG9uZW50LCBpbXBsZW1lbnQgdGhlIGhvb2sgYXMgYSBtZXRob2Qgb24geW91ciBjb21wb25lbnQgc3ViY2xhc3MuXG4gKlxuICogRm9yIGV4YW1wbGUsIHRvIGJlIG5vdGlmaWVkIHdoZW4gR2xpbW1lciBoYXMgcmVuZGVyZWQgeW91ciBjb21wb25lbnQgc28geW91XG4gKiBjYW4gYXR0YWNoIGEgbGVnYWN5IGpRdWVyeSBwbHVnaW4sIGltcGxlbWVudCB0aGUgYGRpZEluc2VydEVsZW1lbnQoKWAgbWV0aG9kOlxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgQ29tcG9uZW50IGZyb20gJ0BnbGltbWVyL2NvbXBvbmVudCc7XG4gKlxuICogZXhwb3J0IGRlZmF1bHQgY2xhc3MgZXh0ZW5kcyBDb21wb25lbnQge1xuICogICBkaWRJbnNlcnRFbGVtZW50KCkge1xuICogICAgICQodGhpcy5lbGVtZW50KS5waWNrYWRhdGUoKTtcbiAqICAgfVxuICogfVxuICogYGBgXG4gKlxuICogIyMgRGF0YSBmb3IgVGVtcGxhdGVzXG4gKlxuICogYENvbXBvbmVudGBzIGhhdmUgdHdvIGRpZmZlcmVudCBraW5kcyBvZiBkYXRhLCBvciBzdGF0ZSwgdGhhdCBjYW4gYmVcbiAqIGRpc3BsYXllZCBpbiB0ZW1wbGF0ZXM6XG4gKlxuICogMS4gQXJndW1lbnRzXG4gKiAyLiBQcm9wZXJ0aWVzXG4gKlxuICogQXJndW1lbnRzIGFyZSBkYXRhIHRoYXQgaXMgcGFzc2VkIGluIHRvIGEgY29tcG9uZW50IGZyb20gaXRzIHBhcmVudFxuICogY29tcG9uZW50LiBGb3IgZXhhbXBsZSwgaWYgSSBoYXZlIGEgYFVzZXJHcmVldGluZ2AgY29tcG9uZW50LCBJIGNhbiBwYXNzIGl0XG4gKiBhIG5hbWUgYW5kIGdyZWV0aW5nIHRvIHVzZTpcbiAqXG4gKiBgYGBoYnNcbiAqIDxVc2VyR3JlZXRpbmcgQG5hbWU9XCJSaWNhcmRvXCIgQGdyZWV0aW5nPVwiT2zDoVwiIC8+XG4gKiBgYGBcbiAqXG4gKiBJbnNpZGUgbXkgYFVzZXJHcmVldGluZ2AgdGVtcGxhdGUsIEkgY2FuIGFjY2VzcyB0aGUgYEBuYW1lYCBhbmQgYEBncmVldGluZ2BcbiAqIGFyZ3VtZW50cyB0aGF0IEkndmUgYmVlbiBnaXZlbjpcbiAqXG4gKiBgYGBoYnNcbiAqIHt7QGdyZWV0aW5nfX0sIHt7QG5hbWV9fSFcbiAqIGBgYFxuICpcbiAqIEFyZ3VtZW50cyBhcmUgYWxzbyBhdmFpbGFibGUgaW5zaWRlIG15IGNvbXBvbmVudDpcbiAqXG4gKiBgYGB0c1xuICogY29uc29sZS5sb2codGhpcy5hcmdzLmdyZWV0aW5nKTsgLy8gcHJpbnRzIFwiT2zDoVwiXG4gKiBgYGBcbiAqXG4gKiBQcm9wZXJ0aWVzLCBvbiB0aGUgb3RoZXIgaGFuZCwgYXJlIGludGVybmFsIHRvIHRoZSBjb21wb25lbnQgYW5kIGRlY2xhcmVkIGluXG4gKiB0aGUgY2xhc3MuIFlvdSBjYW4gdXNlIHByb3BlcnRpZXMgdG8gc3RvcmUgZGF0YSB0aGF0IHlvdSB3YW50IHRvIHNob3cgaW4gdGhlXG4gKiB0ZW1wbGF0ZSwgb3IgcGFzcyB0byBhbm90aGVyIGNvbXBvbmVudCBhcyBhbiBhcmd1bWVudC5cbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IENvbXBvbmVudCBmcm9tICdAZ2xpbW1lci9jb21wb25lbnQnO1xuICpcbiAqIGV4cG9ydCBkZWZhdWx0IGNsYXNzIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAqICAgdXNlciA9IHtcbiAqICAgICBuYW1lOiAnUm9iYmllJ1xuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBJbiB0aGUgYWJvdmUgZXhhbXBsZSwgd2UndmUgZGVmaW5lZCBhIGNvbXBvbmVudCB3aXRoIGEgYHVzZXJgIHByb3BlcnR5IHRoYXRcbiAqIGNvbnRhaW5zIGFuIG9iamVjdCB3aXRoIGl0cyBvd24gYG5hbWVgIHByb3BlcnR5LlxuICpcbiAqIFdlIGNhbiByZW5kZXIgdGhhdCBwcm9wZXJ0eSBpbiBvdXIgdGVtcGxhdGU6XG4gKlxuICogYGBgaGJzXG4gKiBIZWxsbywge3t1c2VyLm5hbWV9fSFcbiAqIGBgYFxuICpcbiAqIFdlIGNhbiBhbHNvIHRha2UgdGhhdCBwcm9wZXJ0eSBhbmQgcGFzcyBpdCBhcyBhbiBhcmd1bWVudCB0byB0aGVcbiAqIGBVc2VyR3JlZXRpbmdgIGNvbXBvbmVudCB3ZSBkZWZpbmVkIGFib3ZlOlxuICpcbiAqIGBgYGhic1xuICogPFVzZXJHcmVldGluZyBAZ3JlZXRpbmc9XCJIZWxsb1wiIEBuYW1lPXt7dXNlci5uYW1lfX0gLz5cbiAqIGBgYFxuICpcbiAqICMjIEFyZ3VtZW50cyB2cy4gUHJvcGVydGllc1xuICpcbiAqIFJlbWVtYmVyLCBhcmd1bWVudHMgYXJlIGRhdGEgdGhhdCB3YXMgZ2l2ZW4gdG8geW91ciBjb21wb25lbnQgYnkgaXRzIHBhcmVudFxuICogY29tcG9uZW50LCBhbmQgcHJvcGVydGllcyBhcmUgZGF0YSB5b3VyIGNvbXBvbmVudCBoYXMgZGVmaW5lZCBmb3IgaXRzZWxmLlxuICpcbiAqIFlvdSBjYW4gdGVsbCB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIGFyZ3VtZW50cyBhbmQgcHJvcGVydGllcyBpbiB0ZW1wbGF0ZXNcbiAqIGJlY2F1c2UgYXJndW1lbnRzIGFsd2F5cyBzdGFydCB3aXRoIGFuIGBAYCBzaWduICh0aGluayBcIkEgaXMgZm9yIGFyZ3VtZW50c1wiKTpcbiAqXG4gKiBgYGBoYnNcbiAqIHt7QGZpcnN0TmFtZX19XG4gKiBgYGBcbiAqXG4gKiBXZSBrbm93IHRoYXQgYEBmaXJzdE5hbWVgIGNhbWUgZnJvbSB0aGUgcGFyZW50IGNvbXBvbmVudCwgbm90IHRoZSBjdXJyZW50XG4gKiBjb21wb25lbnQsIGJlY2F1c2UgaXQgc3RhcnRzIHdpdGggYEBgIGFuZCBpcyB0aGVyZWZvcmUgYW4gYXJndW1lbnQuXG4gKlxuICogT24gdGhlIG90aGVyIGhhbmQsIGlmIHdlIHNlZTpcbiAqXG4gKiBgYGBoYnNcbiAqIHt7bmFtZX19XG4gKiBgYGBcbiAqXG4gKiBXZSBrbm93IHRoYXQgYG5hbWVgIGlzIGEgcHJvcGVydHkgb24gdGhlIGNvbXBvbmVudC4gSWYgd2Ugd2FudCB0byBrbm93IHdoZXJlXG4gKiB0aGUgZGF0YSBpcyBjb21pbmcgZnJvbSwgd2UgY2FuIGdvIGxvb2sgYXQgb3VyIGNvbXBvbmVudCBjbGFzcyB0byBmaW5kIG91dC5cbiAqXG4gKiBJbnNpZGUgdGhlIGNvbXBvbmVudCBpdHNlbGYsIGFyZ3VtZW50cyBhbHdheXMgc2hvdyB1cCBpbnNpZGUgdGhlIGNvbXBvbmVudCdzXG4gKiBgYXJnc2AgcHJvcGVydHkuIEZvciBleGFtcGxlLCBpZiBge3tAZmlyc3ROYW1lfX1gIGlzIGBUb21gIGluIHRoZSB0ZW1wbGF0ZSxcbiAqIGluc2lkZSB0aGUgY29tcG9uZW50IGB0aGlzLmFyZ3MuZmlyc3ROYW1lYCB3b3VsZCBhbHNvIGJlIGBUb21gLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNlQ29tcG9uZW50PFQgPSBvYmplY3Q+IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgY29tcG9uZW50IGFuZCBhc3NpZ25zIGl0c2VsZiB0aGUgcGFzc2VkIHByb3BlcnRpZXMuIFlvdVxuICAgKiBzaG91bGQgbm90IGNvbnN0cnVjdCBuZXcgY29tcG9uZW50cyB5b3Vyc2VsZi4gSW5zdGVhZCwgR2xpbW1lciB3aWxsXG4gICAqIGluc3RhbnRpYXRlIG5ldyBjb21wb25lbnRzIGF1dG9tYXRpY2FsbHkgYXMgaXQgcmVuZGVycy5cbiAgICpcbiAgICogQHBhcmFtIG93bmVyXG4gICAqIEBwYXJhbSBhcmdzXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihvd25lcjogdW5rbm93biwgYXJnczogVCkge1xuICAgIGlmIChERUJVRyAmJiAhKG93bmVyICE9PSBudWxsICYmIHR5cGVvZiBvd25lciA9PT0gJ29iamVjdCcgJiYgQVJHU19TRVQuaGFzKGFyZ3MpKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgWW91IG11c3QgcGFzcyBib3RoIHRoZSBvd25lciBhbmQgYXJncyB0byBzdXBlcigpIGluIHlvdXIgY29tcG9uZW50OiAke1xuICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IubmFtZVxuICAgICAgICB9LiBZb3UgY2FuIHBhc3MgdGhlbSBkaXJlY3RseSwgb3IgdXNlIC4uLmFyZ3VtZW50cyB0byBwYXNzIGFsbCBhcmd1bWVudHMgdGhyb3VnaC5gXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgc2V0T3duZXIodGhpcywgb3duZXIgYXMgYW55KTtcblxuICAgIERFU1RST1lJTkcuc2V0KHRoaXMsIGZhbHNlKTtcbiAgICBERVNUUk9ZRUQuc2V0KHRoaXMsIGZhbHNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBOYW1lZCBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBjb21wb25lbnQgZnJvbSBpdHMgcGFyZW50IGNvbXBvbmVudC5cbiAgICogVGhleSBjYW4gYmUgYWNjZXNzZWQgaW4gSmF2YVNjcmlwdCB2aWEgYHRoaXMuYXJncy5hcmd1bWVudE5hbWVgIGFuZCBpbiB0aGUgdGVtcGxhdGUgdmlhIGBAYXJndW1lbnROYW1lYC5cbiAgICpcbiAgICogU2F5IHlvdSBoYXZlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50LCB3aGljaCB3aWxsIGhhdmUgdHdvIGBhcmdzYCwgYGZpcnN0TmFtZWAgYW5kIGBsYXN0TmFtZWA6XG4gICAqXG4gICAqIGBgYGhic1xuICAgKiA8bXktY29tcG9uZW50IEBmaXJzdE5hbWU9XCJBcnRodXJcIiBAbGFzdE5hbWU9XCJEZW50XCIgLz5cbiAgICogYGBgXG4gICAqXG4gICAqIElmIHlvdSBuZWVkZWQgdG8gY2FsY3VsYXRlIGBmdWxsTmFtZWAgYnkgY29tYmluaW5nIGJvdGggb2YgdGhlbSwgeW91IHdvdWxkIGRvOlxuICAgKlxuICAgKiBgYGB0c1xuICAgKiBkaWRJbnNlcnRFbGVtZW50KCkge1xuICAgKiAgIGNvbnNvbGUubG9nKGBIaSwgbXkgZnVsbCBuYW1lIGlzICR7dGhpcy5hcmdzLmZpcnN0TmFtZX0gJHt0aGlzLmFyZ3MubGFzdE5hbWV9YCk7XG4gICAqIH1cbiAgICogYGBgXG4gICAqXG4gICAqIFdoaWxlIGluIHRoZSB0ZW1wbGF0ZSB5b3UgY291bGQgZG86XG4gICAqXG4gICAqIGBgYGhic1xuICAgKiA8cD5XZWxjb21lLCB7e0BmaXJzdE5hbWV9fSB7e0BsYXN0TmFtZX19ITwvcD5cbiAgICogYGBgXG4gICAqL1xuICBhcmdzOiBSZWFkb25seTxUPjtcblxuICBnZXQgaXNEZXN0cm95aW5nKCkge1xuICAgIHJldHVybiBERVNUUk9ZSU5HLmdldCh0aGlzKTtcbiAgfVxuXG4gIGdldCBpc0Rlc3Ryb3llZCgpIHtcbiAgICByZXR1cm4gREVTVFJPWUVELmdldCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgYmVmb3JlIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBET00uXG4gICAqL1xuICB3aWxsRGVzdHJveSgpIHt9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9