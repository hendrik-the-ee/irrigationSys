define('@glimmer/util', ['exports', '@glimmer/env'], function (exports, env) { 'use strict';

  var EMPTY_ARRAY = Object.freeze([]);

  // import Logger from './logger';
  // let alreadyWarned = false;
  function debugAssert(test, msg) {
    // if (!alreadyWarned) {
    //   alreadyWarned = true;
    //   Logger.warn("Don't leave debug assertions on in public builds");
    // }
    if (!test) {
      throw new Error(msg || 'assertion failure');
    }
  }
  function deprecate(desc) {
    console.warn("DEPRECATION: " + desc);
  }

  var GUID = 0;
  function initializeGuid(object) {
    return object._guid = ++GUID;
  }
  function ensureGuid(object) {
    return object._guid || initializeGuid(object);
  }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
  function dict() {
    return Object.create(null);
  }
  function isDict(u) {
    return u !== null && u !== undefined;
  }
  function isObject(u) {
    return typeof u === 'object' && u !== null;
  }
  var DictSet =
  /*#__PURE__*/
  function () {
    function DictSet() {
      this.dict = dict();
    }

    var _proto = DictSet.prototype;

    _proto.add = function add(obj) {
      if (typeof obj === 'string') this.dict[obj] = obj;else this.dict[ensureGuid(obj)] = obj;
      return this;
    };

    _proto["delete"] = function _delete(obj) {
      if (typeof obj === 'string') delete this.dict[obj];else if (obj._guid) delete this.dict[obj._guid];
    };

    return DictSet;
  }();
  var StackImpl =
  /*#__PURE__*/
  function () {
    function StackImpl() {
      this.stack = [];
      this.current = null;
    }

    var _proto2 = StackImpl.prototype;

    _proto2.push = function push(item) {
      this.current = item;
      this.stack.push(item);
    };

    _proto2.pop = function pop() {
      var item = this.stack.pop();
      var len = this.stack.length;
      this.current = len === 0 ? null : this.stack[len - 1];
      return item === undefined ? null : item;
    };

    _proto2.nth = function nth(from) {
      var len = this.stack.length;
      return len < from ? null : this.stack[len - from];
    };

    _proto2.isEmpty = function isEmpty() {
      return this.stack.length === 0;
    };

    _proto2.toArray = function toArray() {
      return this.stack;
    };

    _createClass(StackImpl, [{
      key: "size",
      get: function get() {
        return this.stack.length;
      }
    }]);

    return StackImpl;
  }();

  function keys(obj) {
    return Object.keys(obj);
  }
  function unwrap(val) {
    if (val === null || val === undefined) throw new Error("Expected value to be present");
    return val;
  }
  function expect(val, message) {
    if (val === null || val === undefined) throw new Error(message);
    return val;
  }
  function unreachable(message) {
    if (message === void 0) {
      message = 'unreachable';
    }

    return new Error(message);
  }
  function exhausted(value) {
    throw new Error("Exhausted " + value);
  }
  var tuple = function tuple() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return args;
  };
  var symbol = typeof Symbol !== 'undefined' ? Symbol : function (key) {
    return "__" + key + Math.floor(Math.random() * Date.now()) + "__";
  };

  var DESTROY = symbol('DESTROY');
  function isDestroyable(value) {
    return !!(value && value[DESTROY] !== undefined);
  }
  function isStringDestroyable(value) {
    return !!(value && typeof value === 'object' && typeof value.destroy === 'function');
  }

  function clearElement(parent) {
    var current = parent.firstChild;

    while (current) {
      var next = current.nextSibling;
      parent.removeChild(current);
      current = next;
    }
  }

  var SERIALIZATION_FIRST_NODE_STRING = '%+b:0%';
  function isSerializationFirstNode(node) {
    return node.nodeValue === SERIALIZATION_FIRST_NODE_STRING;
  }

  function _defineProperties$1(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$1(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$1(Constructor.prototype, protoProps); if (staticProps) _defineProperties$1(Constructor, staticProps); return Constructor; }
  var LINKED = new WeakMap();
  var WILL_DROP = symbol('WILL_DROP');
  var DID_DROP = symbol('DID_DROP');
  var CHILDREN = symbol('CHILDREN');
  var DESTRUCTORS = new WeakMap();
  function isDrop(value) {
    if (value === null || typeof value !== 'object') return false;
    return value[DID_DROP] !== undefined;
  }
  function associate(parent, child) {
    associateDestructor(parent, destructor(child));
  }
  function associateDestructor(parent, child) {
    var associated = LINKED.get(parent);

    if (!associated) {
      associated = new Set();
      LINKED.set(parent, associated);
    }

    associated.add(child);
  }
  function peekAssociated(parent) {
    return LINKED.get(parent) || null;
  }
  function takeAssociated(parent) {
    var linked = LINKED.get(parent);

    if (linked && linked.size > 0) {
      LINKED["delete"](parent);
      return linked;
    } else {
      return null;
    }
  }
  function willDestroyAssociated(parent) {
    var associated = LINKED.get(parent);

    if (associated) {
      associated.forEach(function (item) {
        item[WILL_DROP]();
      });
    }
  }
  function didDestroyAssociated(parent) {
    var associated = LINKED.get(parent);

    if (associated) {
      associated.forEach(function (item) {
        item[DID_DROP]();
        associated["delete"](item);
      });
    }
  }
  function destructor(value) {
    var d = DESTRUCTORS.get(value);

    if (!d) {
      if (isDestroyable(value)) {
        d = new DestroyableDestructor(value);
      } else if (isStringDestroyable(value)) {
        d = new StringDestroyableDestructor(value);
      } else {
        d = new SimpleDestructor(value);
      }

      DESTRUCTORS.set(value, d);
    }

    return d;
  }
  function snapshot(values) {
    return new SnapshotDestructor(values);
  }

  var SnapshotDestructor =
  /*#__PURE__*/
  function () {
    function SnapshotDestructor(destructors) {
      this.destructors = destructors;
    }

    var _proto = SnapshotDestructor.prototype;

    _proto[WILL_DROP] = function () {
      this.destructors.forEach(function (item) {
        return item[WILL_DROP]();
      });
    };

    _proto[DID_DROP] = function () {
      this.destructors.forEach(function (item) {
        return item[DID_DROP]();
      });
    };

    _proto.toString = function toString() {
      return 'SnapshotDestructor';
    };

    _createClass$1(SnapshotDestructor, [{
      key: CHILDREN,
      get: function get() {
        return this.destructors;
      }
    }]);

    return SnapshotDestructor;
  }();

  var DestroyableDestructor =
  /*#__PURE__*/
  function () {
    function DestroyableDestructor(inner) {
      this.inner = inner;
    }

    var _proto2 = DestroyableDestructor.prototype;

    _proto2[WILL_DROP] = function () {
      willDestroyAssociated(this.inner);
    };

    _proto2[DID_DROP] = function () {
      this.inner[DESTROY]();
      didDestroyAssociated(this.inner);
    };

    _proto2.toString = function toString() {
      return 'DestroyableDestructor';
    };

    _createClass$1(DestroyableDestructor, [{
      key: CHILDREN,
      get: function get() {
        return LINKED.get(this.inner) || [];
      }
    }]);

    return DestroyableDestructor;
  }();

  var StringDestroyableDestructor =
  /*#__PURE__*/
  function () {
    function StringDestroyableDestructor(inner) {
      this.inner = inner;
    }

    var _proto3 = StringDestroyableDestructor.prototype;

    _proto3[WILL_DROP] = function () {
      if (typeof this.inner.willDestroy === 'function') {
        this.inner.willDestroy();
      }

      willDestroyAssociated(this.inner);
    };

    _proto3[DID_DROP] = function () {
      this.inner.destroy();
      didDestroyAssociated(this.inner);
    };

    _proto3.toString = function toString() {
      return 'StringDestroyableDestructor';
    };

    _createClass$1(StringDestroyableDestructor, [{
      key: CHILDREN,
      get: function get() {
        return LINKED.get(this.inner) || [];
      }
    }]);

    return StringDestroyableDestructor;
  }();

  var SimpleDestructor =
  /*#__PURE__*/
  function () {
    function SimpleDestructor(inner) {
      this.inner = inner;
    }

    var _proto4 = SimpleDestructor.prototype;

    _proto4[WILL_DROP] = function () {
      willDestroyAssociated(this.inner);
    };

    _proto4[DID_DROP] = function () {
      didDestroyAssociated(this.inner);
    };

    _proto4.toString = function toString() {
      return 'SimpleDestructor';
    };

    _createClass$1(SimpleDestructor, [{
      key: CHILDREN,
      get: function get() {
        return LINKED.get(this.inner) || [];
      }
    }]);

    return SimpleDestructor;
  }();

  var ListContentsDestructor =
  /*#__PURE__*/
  function () {
    function ListContentsDestructor(inner) {
      this.inner = inner;
    }

    var _proto5 = ListContentsDestructor.prototype;

    _proto5[WILL_DROP] = function () {
      this.inner.forEachNode(function (d) {
        return destructor(d)[WILL_DROP]();
      });
    };

    _proto5[DID_DROP] = function () {
      this.inner.forEachNode(function (d) {
        return destructor(d)[DID_DROP]();
      });
    };

    _proto5.toString = function toString() {
      return 'ListContentsDestructor';
    };

    _createClass$1(ListContentsDestructor, [{
      key: CHILDREN,
      get: function get() {
        var out = [];
        this.inner.forEachNode(function (d) {
          return out.push.apply(out, destructor(d)[CHILDREN]);
        });
        return out;
      }
    }]);

    return ListContentsDestructor;
  }();
  function debugDropTree(inner) {
    var hasDrop = isDrop(inner);
    var rawChildren = LINKED.get(inner) || null;
    var children = null;

    if (rawChildren) {
      children = [];

      for (var _iterator = rawChildren, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref = _i.value;
        }

        var child = _ref;
        children.push(debugDropTree(child));
      }
    }

    var obj = Object.create(null);
    obj.inner = inner;

    if (children) {
      obj.children = children;
    }

    obj.hasDrop = hasDrop;
    return obj;
  }
  function printDropTree(inner) {
    printDrop(destructor(inner));
  }
  function printDrop(inner) {
    console.group(String(inner));
    console.log(inner);
    var children = inner[CHILDREN] || null;

    if (children) {
      for (var _iterator2 = children, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
        var _ref2;

        if (_isArray2) {
          if (_i2 >= _iterator2.length) break;
          _ref2 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done) break;
          _ref2 = _i2.value;
        }

        var child = _ref2;
        printDrop(child);
      }
    }

    console.groupEnd();
  }

  function _defineProperties$2(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$2(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$2(Constructor.prototype, protoProps); if (staticProps) _defineProperties$2(Constructor, staticProps); return Constructor; }
  var ListNode = function ListNode(value) {
    this.next = null;
    this.prev = null;
    this.value = value;
  };
  var LinkedList =
  /*#__PURE__*/
  function () {
    function LinkedList() {
      this.clear();
    }

    var _proto = LinkedList.prototype;

    _proto.head = function head() {
      return this._head;
    };

    _proto.tail = function tail() {
      return this._tail;
    };

    _proto.clear = function clear() {
      this._head = this._tail = null;
    };

    _proto.toArray = function toArray() {
      var out = [];
      this.forEachNode(function (n) {
        return out.push(n);
      });
      return out;
    };

    _proto.nextNode = function nextNode(node) {
      return node.next;
    };

    _proto.forEachNode = function forEachNode(callback) {
      var node = this._head;

      while (node !== null) {
        callback(node);
        node = node.next;
      }
    };

    _proto.insertBefore = function insertBefore(node, reference) {
      if (reference === void 0) {
        reference = null;
      }

      if (reference === null) return this.append(node);
      if (reference.prev) reference.prev.next = node;else this._head = node;
      node.prev = reference.prev;
      node.next = reference;
      reference.prev = node;
      return node;
    };

    _proto.append = function append(node) {
      var tail = this._tail;

      if (tail) {
        tail.next = node;
        node.prev = tail;
        node.next = null;
      } else {
        this._head = node;
      }

      return this._tail = node;
    };

    _proto.remove = function remove(node) {
      if (node.prev) node.prev.next = node.next;else this._head = node.next;
      if (node.next) node.next.prev = node.prev;else this._tail = node.prev;
      return node;
    };

    _proto[WILL_DROP] = function () {
      this.forEachNode(function (d) {
        return destructor(d)[WILL_DROP]();
      });
    };

    _proto[DID_DROP] = function () {
      this.forEachNode(function (d) {
        return destructor(d)[DID_DROP]();
      });
    };

    _createClass$2(LinkedList, [{
      key: CHILDREN,
      get: function get() {
        var out = [];
        this.forEachNode(function (d) {
          return out.push.apply(out, destructor(d)[CHILDREN]);
        });
        return out;
      }
    }]);

    return LinkedList;
  }();
  var ListSlice =
  /*#__PURE__*/
  function () {
    function ListSlice(head, tail) {
      this._head = head;
      this._tail = tail;
    }

    var _proto2 = ListSlice.prototype;

    _proto2.forEachNode = function forEachNode(callback) {
      var node = this._head;

      while (node !== null) {
        callback(node);
        node = this.nextNode(node);
      }
    };

    _proto2.head = function head() {
      return this._head;
    };

    _proto2.tail = function tail() {
      return this._tail;
    };

    _proto2.toArray = function toArray() {
      var out = [];
      this.forEachNode(function (n) {
        return out.push(n);
      });
      return out;
    };

    _proto2.nextNode = function nextNode(node) {
      if (node === this._tail) return null;
      return node.next;
    };

    return ListSlice;
  }();
  var EMPTY_SLICE = new ListSlice(null, null);

  var objKeys = Object.keys;
  function assign(obj) {
    for (var i = 1; i < arguments.length; i++) {
      var assignment = arguments[i];
      if (assignment === null || typeof assignment !== 'object') continue;
      var keys = objKeys(assignment);

      for (var j = 0; j < keys.length; j++) {
        var key = keys[j];
        obj[key] = assignment[key];
      }
    }

    return obj;
  }
  function fillNulls(count) {
    var arr = new Array(count);

    for (var i = 0; i < count; i++) {
      arr[i] = null;
    }

    return arr;
  }
  function values(obj) {
    var vals = [];

    for (var key in obj) {
      vals.push(obj[key]);
    }

    return vals;
  }

  function strip(strings) {
    var out = '';

    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    for (var i = 0; i < strings.length; i++) {
      var string = strings[i];
      var dynamic = args[i] !== undefined ? String(args[i]) : '';
      out += "" + string + dynamic;
    }

    var lines = out.split('\n');

    while (lines.length && lines[0].match(/^\s*$/)) {
      lines.shift();
    }

    while (lines.length && lines[lines.length - 1].match(/^\s*$/)) {
      lines.pop();
    }

    var min = Infinity;

    for (var _iterator = lines, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var line = _ref;
      var leading = line.match(/^\s*/)[0].length;
      min = Math.min(min, leading);
    }

    var stripped = [];

    for (var _iterator2 = lines, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var _line = _ref2;
      stripped.push(_line.slice(min));
    }

    return stripped.join('\n');
  }

  /**
   * Encodes a value that can be stored directly instead of being a handle.
   *
   * Immediates use the positive half of 32bits
   *
   * @param value - the value to be encoded.
   */


  function encodeImmediate(value) {
    if (typeof value === 'number') {
      // 1073741827 - (-1) == 1073741828
      // 1073741827 - (-1073741820) == 2147483647
      // positive it stays as is
      // 0 - 1073741823


      return value < 0 ? 1073741827
      /* NEGATIVE_BASE */
      - value : value;
    }

    if (value === false) {
      return 1073741824
      /* FALSE */
      ;
    }

    if (value === true) {
      return 1073741825
      /* TRUE */
      ;
    }

    if (value === null) {
      return 1073741826
      /* NULL */
      ;
    }

    if (value === undefined) {
      return 1073741827
      /* UNDEFINED */
      ;
    }

    return exhausted(value);
  }
  /**
   * Decodes an immediate into its value.
   *
   * @param value - the encoded immediate value
   */

  function decodeImmediate(value) {

    if (value > 1073741823
    /* MAX_INT */
    ) {
        switch (value) {
          case 1073741824
          /* FALSE */
          :
            return false;

          case 1073741825
          /* TRUE */
          :
            return true;

          case 1073741826
          /* NULL */
          :
            return null;

          case 1073741827
          /* UNDEFINED */
          :
            return undefined;

          default:
            // map 1073741828 to 2147483647 to -1 to -1073741820
            // 1073741827 - 1073741828 == -1
            // 1073741827 - 2147483647 == -1073741820
            return 1073741827
            /* NEGATIVE_BASE */
            - value;
        }
      }

    return value;
  }
  /**
   * True if the number can be stored directly or false if it needs a handle.
   *
   * This is used on any number type to see if it can be directly encoded.
   */

  function isSmallInt(num) {
    return isInt(num, -1073741820
    /* MIN_INT */
    , 1073741823
    /* MAX_INT */
    );
  }
  /**
   * True if the encoded int32 operand or encoded stack int32 is a handle.
   */

  function isHandle(encoded) {

    return encoded < 0;
  }
  /**
   * Encodes an index to an operand or stack handle.
   */

  function encodeHandle(index, maxIndex
  /* MAX_INDEX */
  , maxHandle
  /* MAX_HANDLE */
  ) {
    if (maxIndex === void 0) {
      maxIndex = 2147483647;
    }

    if (maxHandle === void 0) {
      maxHandle = -1;
    }

    if (index > maxIndex) {
      throw new Error("index " + index + " overflowed range 0 to " + maxIndex);
    } // -1 - 0 == -1
    // -1 - 1073741823 == -1073741824
    // -1073741825 - 0 == -1073741825
    // -1073741825 - 1073741823 == -2147483648


    return maxHandle - index;
  }
  /**
   * Decodes the index from the specified operand or stack handle.
   */

  function decodeHandle(handle, maxHandle
  /* MAX_HANDLE */
  ) {
    if (maxHandle === void 0) {
      maxHandle = -1;
    }
    // -1 - -1073741824 == 1073741823
    // -1073741825 - -1073741825 == 0
    // -1073741825 - -2147483648 == 1073741823


    return maxHandle - handle;
  }

  function isInt(num, min, max) {
    // this is the same as Math.floor(num) === num
    // also NaN % 1 is NaN and Infinity % 1 is NaN so both should fail
    return num % 1 === 0 && num >= min && num <= max;
  }

  function unwrapHandle(handle) {
    if (typeof handle === 'number') {
      return handle;
    } else {
      var error = handle.errors[0];
      throw new Error("Compile Error: " + error.problem + " @ " + error.span.start + ".." + error.span.end);
    }
  }
  function unwrapTemplate(template) {
    if (template.result === 'error') {
      throw new Error("Compile Error: " + template.problem + " @ " + template.span.start + ".." + template.span.end);
    }

    return template;
  }
  function extractHandle(handle) {
    if (typeof handle === 'number') {
      return handle;
    } else {
      return handle.handle;
    }
  }
  function isOkHandle(handle) {
    return typeof handle === 'number';
  }
  function isErrHandle(handle) {
    return typeof handle === 'number';
  }

  var debugToString;

  if (env.DEBUG) {
    var getFunctionName = function getFunctionName(fn) {
      var functionName = fn.name;

      if (functionName === undefined) {
        var match = Function.prototype.toString.call(fn).match(/function (\w+)\s*\(/);
        functionName = match && match[1] || '';
      }

      return functionName.replace(/^bound /, '');
    };

    var getObjectName = function getObjectName(obj) {
      var name;
      var className;

      if (obj.constructor && obj.constructor !== Object) {
        className = getFunctionName(obj.constructor);
      }

      if ('toString' in obj && obj.toString !== Object.prototype.toString && obj.toString !== Function.prototype.toString) {
        name = obj.toString();
      } // If the class has a decent looking name, and the `toString` is one of the
      // default Ember toStrings, replace the constructor portion of the toString
      // with the class name. We check the length of the class name to prevent doing
      // this when the value is minified.


      if (name && name.match(/<.*:ember\d+>/) && className && className[0] !== '_' && className.length > 2 && className !== 'Class') {
        return name.replace(/<.*:/, "<" + className + ":");
      }

      return name || className;
    };

    var getPrimitiveName = function getPrimitiveName(value) {
      return String(value);
    };

    debugToString = function debugToString(value) {
      if (typeof value === 'function') {
        return getFunctionName(value) || "(unknown function)";
      } else if (typeof value === 'object' && value !== null) {
        return getObjectName(value) || "(unknown object)";
      } else {
        return getPrimitiveName(value);
      }
    };
  }

  var debugToString$1 = debugToString;

  function assertNever(value, desc) {
    if (desc === void 0) {
      desc = 'unexpected unreachable branch';
    }

    console.log('unreachable', value);
    console.trace(desc + " :: " + JSON.stringify(value) + " (" + value + ")");
  }

  exports.CHILDREN = CHILDREN;
  exports.DESTROY = DESTROY;
  exports.DESTRUCTORS = DESTRUCTORS;
  exports.DID_DROP = DID_DROP;
  exports.DictSet = DictSet;
  exports.EMPTY_ARRAY = EMPTY_ARRAY;
  exports.EMPTY_SLICE = EMPTY_SLICE;
  exports.LINKED = LINKED;
  exports.LinkedList = LinkedList;
  exports.ListContentsDestructor = ListContentsDestructor;
  exports.ListNode = ListNode;
  exports.ListSlice = ListSlice;
  exports.SERIALIZATION_FIRST_NODE_STRING = SERIALIZATION_FIRST_NODE_STRING;
  exports.Stack = StackImpl;
  exports.WILL_DROP = WILL_DROP;
  exports.assert = debugAssert;
  exports.assertNever = assertNever;
  exports.assign = assign;
  exports.associate = associate;
  exports.associateDestructor = associateDestructor;
  exports.clearElement = clearElement;
  exports.debugDropTree = debugDropTree;
  exports.debugToString = debugToString$1;
  exports.decodeHandle = decodeHandle;
  exports.decodeImmediate = decodeImmediate;
  exports.deprecate = deprecate;
  exports.destructor = destructor;
  exports.dict = dict;
  exports.didDestroyAssociated = didDestroyAssociated;
  exports.encodeHandle = encodeHandle;
  exports.encodeImmediate = encodeImmediate;
  exports.ensureGuid = ensureGuid;
  exports.exhausted = exhausted;
  exports.expect = expect;
  exports.extractHandle = extractHandle;
  exports.fillNulls = fillNulls;
  exports.initializeGuid = initializeGuid;
  exports.isDestroyable = isDestroyable;
  exports.isDict = isDict;
  exports.isDrop = isDrop;
  exports.isErrHandle = isErrHandle;
  exports.isHandle = isHandle;
  exports.isObject = isObject;
  exports.isOkHandle = isOkHandle;
  exports.isSerializationFirstNode = isSerializationFirstNode;
  exports.isSmallInt = isSmallInt;
  exports.isStringDestroyable = isStringDestroyable;
  exports.keys = keys;
  exports.peekAssociated = peekAssociated;
  exports.printDrop = printDrop;
  exports.printDropTree = printDropTree;
  exports.snapshot = snapshot;
  exports.strip = strip;
  exports.symbol = symbol;
  exports.takeAssociated = takeAssociated;
  exports.tuple = tuple;
  exports.unreachable = unreachable;
  exports.unwrap = unwrap;
  exports.unwrapHandle = unwrapHandle;
  exports.unwrapTemplate = unwrapTemplate;
  exports.values = values;
  exports.willDestroyAssociated = willDestroyAssociated;

  Object.defineProperty(exports, '__esModule', { value: true });

});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2xpbW1lci11dGlsLmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci91dGlsL2xpYi9hcnJheS11dGlscy50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvbGliL2Fzc2VydC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvbGliL2d1aWQudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci91dGlsL2xpYi9jb2xsZWN0aW9ucy50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvbGliL3BsYXRmb3JtLXV0aWxzLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvdXRpbC9saWIvZGVzdHJveS50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvbGliL2RvbS50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvbGliL2lzLXNlcmlhbGl6YXRpb24tZmlyc3Qtbm9kZS50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvbGliL2xpZmV0aW1lcy50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvbGliL2xpc3QtdXRpbHMudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci91dGlsL2xpYi9vYmplY3QtdXRpbHMudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci91dGlsL2xpYi9zdHJpbmcudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci91dGlsL2xpYi9pbW1lZGlhdGUudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci91dGlsL2xpYi90ZW1wbGF0ZS50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvbGliL2RlYnVnLXRvLXN0cmluZy50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvaW5kZXgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IEVNUFRZX0FSUkFZOiBhbnlbXSA9IE9iamVjdC5mcmVlemUoW10pIGFzIGFueTtcbiIsIi8vIGltcG9ydCBMb2dnZXIgZnJvbSAnLi9sb2dnZXInO1xuXG4vLyBsZXQgYWxyZWFkeVdhcm5lZCA9IGZhbHNlO1xuXG5leHBvcnQgZnVuY3Rpb24gZGVidWdBc3NlcnQodGVzdDogYW55LCBtc2c6IHN0cmluZykge1xuICAvLyBpZiAoIWFscmVhZHlXYXJuZWQpIHtcbiAgLy8gICBhbHJlYWR5V2FybmVkID0gdHJ1ZTtcbiAgLy8gICBMb2dnZXIud2FybihcIkRvbid0IGxlYXZlIGRlYnVnIGFzc2VydGlvbnMgb24gaW4gcHVibGljIGJ1aWxkc1wiKTtcbiAgLy8gfVxuXG4gIGlmICghdGVzdCkge1xuICAgIHRocm93IG5ldyBFcnJvcihtc2cgfHwgJ2Fzc2VydGlvbiBmYWlsdXJlJyk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByb2RBc3NlcnQoKSB7fVxuXG5leHBvcnQgZnVuY3Rpb24gZGVwcmVjYXRlKGRlc2M6IHN0cmluZykge1xuICBjb25zb2xlLndhcm4oYERFUFJFQ0FUSU9OOiAke2Rlc2N9YCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlYnVnQXNzZXJ0O1xuIiwibGV0IEdVSUQgPSAwO1xuXG5leHBvcnQgaW50ZXJmYWNlIEhhc0d1aWQge1xuICBfZ3VpZDogbnVtYmVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdGlhbGl6ZUd1aWQob2JqZWN0OiBIYXNHdWlkKTogbnVtYmVyIHtcbiAgcmV0dXJuIChvYmplY3QuX2d1aWQgPSArK0dVSUQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlR3VpZChvYmplY3Q6IEhhc0d1aWQpOiBudW1iZXIge1xuICByZXR1cm4gb2JqZWN0Ll9ndWlkIHx8IGluaXRpYWxpemVHdWlkKG9iamVjdCk7XG59XG4iLCJpbXBvcnQgeyBIYXNHdWlkLCBlbnN1cmVHdWlkIH0gZnJvbSAnLi9ndWlkJztcbmltcG9ydCB7IE9wdGlvbiB9IGZyb20gJy4vcGxhdGZvcm0tdXRpbHMnO1xuaW1wb3J0IHsgRGljdCwgU3RhY2sgfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcblxuZXhwb3J0IGludGVyZmFjZSBTZXQ8VD4ge1xuICBhZGQodmFsdWU6IFQpOiBTZXQ8VD47XG4gIGRlbGV0ZSh2YWx1ZTogVCk6IHZvaWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaWN0PFQgPSB1bmtub3duPigpOiBEaWN0PFQ+IHtcbiAgcmV0dXJuIE9iamVjdC5jcmVhdGUobnVsbCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0RpY3Q8VD4odTogVCk6IHUgaXMgRGljdCAmIFQge1xuICByZXR1cm4gdSAhPT0gbnVsbCAmJiB1ICE9PSB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdDxUPih1OiBUKTogdSBpcyBvYmplY3QgJiBUIHtcbiAgcmV0dXJuIHR5cGVvZiB1ID09PSAnb2JqZWN0JyAmJiB1ICE9PSBudWxsO1xufVxuXG5leHBvcnQgdHlwZSBTZXRNZW1iZXIgPSBIYXNHdWlkIHwgc3RyaW5nO1xuXG5leHBvcnQgY2xhc3MgRGljdFNldDxUIGV4dGVuZHMgU2V0TWVtYmVyPiBpbXBsZW1lbnRzIFNldDxUPiB7XG4gIHByaXZhdGUgZGljdDogRGljdDxUPjtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmRpY3QgPSBkaWN0PFQ+KCk7XG4gIH1cblxuICBhZGQob2JqOiBUKTogU2V0PFQ+IHtcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHRoaXMuZGljdFtvYmogYXMgYW55XSA9IG9iajtcbiAgICBlbHNlIHRoaXMuZGljdFtlbnN1cmVHdWlkKG9iaiBhcyBhbnkpXSA9IG9iajtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGRlbGV0ZShvYmo6IFQpIHtcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIGRlbGV0ZSB0aGlzLmRpY3Rbb2JqIGFzIGFueV07XG4gICAgZWxzZSBpZiAoKG9iaiBhcyBhbnkpLl9ndWlkKSBkZWxldGUgdGhpcy5kaWN0WyhvYmogYXMgYW55KS5fZ3VpZF07XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFN0YWNrSW1wbDxUPiBpbXBsZW1lbnRzIFN0YWNrPFQ+IHtcbiAgcHJpdmF0ZSBzdGFjazogVFtdID0gW107XG4gIHB1YmxpYyBjdXJyZW50OiBPcHRpb248VD4gPSBudWxsO1xuXG4gIHB1YmxpYyBnZXQgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFjay5sZW5ndGg7XG4gIH1cblxuICBwdXNoKGl0ZW06IFQpIHtcbiAgICB0aGlzLmN1cnJlbnQgPSBpdGVtO1xuICAgIHRoaXMuc3RhY2sucHVzaChpdGVtKTtcbiAgfVxuXG4gIHBvcCgpOiBPcHRpb248VD4ge1xuICAgIGxldCBpdGVtID0gdGhpcy5zdGFjay5wb3AoKTtcbiAgICBsZXQgbGVuID0gdGhpcy5zdGFjay5sZW5ndGg7XG4gICAgdGhpcy5jdXJyZW50ID0gbGVuID09PSAwID8gbnVsbCA6IHRoaXMuc3RhY2tbbGVuIC0gMV07XG5cbiAgICByZXR1cm4gaXRlbSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGl0ZW07XG4gIH1cblxuICBudGgoZnJvbTogbnVtYmVyKTogT3B0aW9uPFQ+IHtcbiAgICBsZXQgbGVuID0gdGhpcy5zdGFjay5sZW5ndGg7XG4gICAgcmV0dXJuIGxlbiA8IGZyb20gPyBudWxsIDogdGhpcy5zdGFja1tsZW4gLSBmcm9tXTtcbiAgfVxuXG4gIGlzRW1wdHkoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuc3RhY2subGVuZ3RoID09PSAwO1xuICB9XG5cbiAgdG9BcnJheSgpOiBUW10ge1xuICAgIHJldHVybiB0aGlzLnN0YWNrO1xuICB9XG59XG4iLCJleHBvcnQgdHlwZSBPcHRpb248VD4gPSBUIHwgbnVsbDtcbmV4cG9ydCB0eXBlIE1heWJlPFQ+ID0gT3B0aW9uPFQ+IHwgdW5kZWZpbmVkIHwgdm9pZDtcblxuZXhwb3J0IHR5cGUgRmFjdG9yeTxUPiA9IG5ldyAoLi4uYXJnczogdW5rbm93bltdKSA9PiBUO1xuXG5leHBvcnQgZnVuY3Rpb24ga2V5czxUPihvYmo6IFQpOiBBcnJheTxrZXlvZiBUPiB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopIGFzIEFycmF5PGtleW9mIFQ+O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdW53cmFwPFQ+KHZhbDogTWF5YmU8VD4pOiBUIHtcbiAgaWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCB2YWx1ZSB0byBiZSBwcmVzZW50YCk7XG4gIHJldHVybiB2YWwgYXMgVDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4cGVjdDxUPih2YWw6IE1heWJlPFQ+LCBtZXNzYWdlOiBzdHJpbmcpOiBUIHtcbiAgaWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICByZXR1cm4gdmFsIGFzIFQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bnJlYWNoYWJsZShtZXNzYWdlID0gJ3VucmVhY2hhYmxlJyk6IEVycm9yIHtcbiAgcmV0dXJuIG5ldyBFcnJvcihtZXNzYWdlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4aGF1c3RlZCh2YWx1ZTogbmV2ZXIpOiBuZXZlciB7XG4gIHRocm93IG5ldyBFcnJvcihgRXhoYXVzdGVkICR7dmFsdWV9YCk7XG59XG5cbmV4cG9ydCB0eXBlIExpdCA9IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCB1bmRlZmluZWQgfCBudWxsIHwgdm9pZCB8IHt9O1xuXG5leHBvcnQgY29uc3QgdHVwbGUgPSA8VCBleHRlbmRzIExpdFtdPiguLi5hcmdzOiBUKSA9PiBhcmdzO1xuXG5leHBvcnQgY29uc3Qgc3ltYm9sID1cbiAgdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IFN5bWJvbFxuICAgIDogKGtleTogc3RyaW5nKSA9PiBgX18ke2tleX0ke01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIERhdGUubm93KCkpfV9fYCBhcyBhbnk7XG4iLCJpbXBvcnQgeyBNYXliZSwgU3ltYm9sRGVzdHJveWFibGUsIERlc3Ryb3lhYmxlLCBEZXN0cm95U3ltYm9sIH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBzeW1ib2wgfSBmcm9tICcuL3BsYXRmb3JtLXV0aWxzJztcblxuZXhwb3J0IGNvbnN0IERFU1RST1k6IERlc3Ryb3lTeW1ib2wgPSBzeW1ib2woJ0RFU1RST1knKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzRGVzdHJveWFibGUoXG4gIHZhbHVlOiBNYXliZTxvYmplY3Q+IHwgU3ltYm9sRGVzdHJveWFibGVcbik6IHZhbHVlIGlzIFN5bWJvbERlc3Ryb3lhYmxlIHtcbiAgcmV0dXJuICEhKHZhbHVlICYmICh2YWx1ZSBhcyBTeW1ib2xEZXN0cm95YWJsZSlbREVTVFJPWV0gIT09IHVuZGVmaW5lZCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1N0cmluZ0Rlc3Ryb3lhYmxlKHZhbHVlOiBNYXliZTxQYXJ0aWFsPERlc3Ryb3lhYmxlPj4pOiB2YWx1ZSBpcyBEZXN0cm95YWJsZSB7XG4gIHJldHVybiAhISh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZS5kZXN0cm95ID09PSAnZnVuY3Rpb24nKTtcbn1cbiIsImltcG9ydCB7IE9wdGlvbiB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgU2ltcGxlRWxlbWVudCwgU2ltcGxlTm9kZSB9IGZyb20gJ0BzaW1wbGUtZG9tL2ludGVyZmFjZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGVhckVsZW1lbnQocGFyZW50OiBTaW1wbGVFbGVtZW50KSB7XG4gIGxldCBjdXJyZW50OiBPcHRpb248U2ltcGxlTm9kZT4gPSBwYXJlbnQuZmlyc3RDaGlsZDtcblxuICB3aGlsZSAoY3VycmVudCkge1xuICAgIGxldCBuZXh0ID0gY3VycmVudC5uZXh0U2libGluZztcbiAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoY3VycmVudCk7XG4gICAgY3VycmVudCA9IG5leHQ7XG4gIH1cbn1cbiIsImltcG9ydCB7IFNpbXBsZU5vZGUgfSBmcm9tICdAc2ltcGxlLWRvbS9pbnRlcmZhY2UnO1xuXG5leHBvcnQgY29uc3QgU0VSSUFMSVpBVElPTl9GSVJTVF9OT0RFX1NUUklORyA9ICclK2I6MCUnO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNTZXJpYWxpemF0aW9uRmlyc3ROb2RlKG5vZGU6IFNpbXBsZU5vZGUpOiBib29sZWFuIHtcbiAgcmV0dXJuIG5vZGUubm9kZVZhbHVlID09PSBTRVJJQUxJWkFUSU9OX0ZJUlNUX05PREVfU1RSSU5HO1xufVxuIiwiaW1wb3J0IHsgaXNEZXN0cm95YWJsZSwgaXNTdHJpbmdEZXN0cm95YWJsZSwgREVTVFJPWSB9IGZyb20gJy4vZGVzdHJveSc7XG5pbXBvcnQge1xuICBPcHRpb24sXG4gIFN5bWJvbERlc3Ryb3lhYmxlLFxuICBEZXN0cm95YWJsZSxcbiAgRHJvcCxcbiAgV2lsbERyb3BTeW1ib2wsXG4gIERpZERyb3BTeW1ib2wsXG4gIENoaWxkcmVuU3ltYm9sLFxufSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IExpbmtlZExpc3QsIExpbmtlZExpc3ROb2RlIH0gZnJvbSAnLi9saXN0LXV0aWxzJztcbmltcG9ydCB7IExPQ0FMX0RFQlVHIH0gZnJvbSAnQGdsaW1tZXIvbG9jYWwtZGVidWctZmxhZ3MnO1xuaW1wb3J0IHsgc3ltYm9sIH0gZnJvbSAnLi9wbGF0Zm9ybS11dGlscyc7XG5cbmV4cG9ydCBjb25zdCBMSU5LRUQ6IFdlYWtNYXA8b2JqZWN0LCBTZXQ8RHJvcD4+ID0gbmV3IFdlYWtNYXAoKTtcbmV4cG9ydCBjb25zdCBXSUxMX0RST1A6IFdpbGxEcm9wU3ltYm9sID0gc3ltYm9sKCdXSUxMX0RST1AnKTtcbmV4cG9ydCBjb25zdCBESURfRFJPUDogRGlkRHJvcFN5bWJvbCA9IHN5bWJvbCgnRElEX0RST1AnKTtcbmV4cG9ydCBjb25zdCBDSElMRFJFTjogQ2hpbGRyZW5TeW1ib2wgPSBzeW1ib2woJ0NISUxEUkVOJyk7XG5leHBvcnQgY29uc3QgREVTVFJVQ1RPUlMgPSBuZXcgV2Vha01hcCgpO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNEcm9wKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgRHJvcCB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiAodmFsdWUgYXMgRHJvcClbRElEX0RST1BdICE9PSB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NvY2lhdGUocGFyZW50OiBvYmplY3QsIGNoaWxkOiBvYmplY3QpIHtcbiAgYXNzb2NpYXRlRGVzdHJ1Y3RvcihwYXJlbnQsIGRlc3RydWN0b3IoY2hpbGQpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc29jaWF0ZURlc3RydWN0b3IocGFyZW50OiBvYmplY3QsIGNoaWxkOiBEcm9wKTogdm9pZCB7XG4gIGxldCBhc3NvY2lhdGVkID0gTElOS0VELmdldChwYXJlbnQpO1xuXG4gIGlmICghYXNzb2NpYXRlZCkge1xuICAgIGFzc29jaWF0ZWQgPSBuZXcgU2V0KCk7XG4gICAgTElOS0VELnNldChwYXJlbnQsIGFzc29jaWF0ZWQpO1xuICB9XG5cbiAgYXNzb2NpYXRlZC5hZGQoY2hpbGQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGVla0Fzc29jaWF0ZWQocGFyZW50OiBvYmplY3QpOiBPcHRpb248U2V0PERyb3A+PiB7XG4gIHJldHVybiBMSU5LRUQuZ2V0KHBhcmVudCkgfHwgbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRha2VBc3NvY2lhdGVkKHBhcmVudDogb2JqZWN0KTogT3B0aW9uPFNldDxEcm9wPj4ge1xuICBsZXQgbGlua2VkID0gTElOS0VELmdldChwYXJlbnQpO1xuXG4gIGlmIChsaW5rZWQgJiYgbGlua2VkLnNpemUgPiAwKSB7XG4gICAgTElOS0VELmRlbGV0ZShwYXJlbnQpO1xuICAgIHJldHVybiBsaW5rZWQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdpbGxEZXN0cm95QXNzb2NpYXRlZChwYXJlbnQ6IG9iamVjdCkge1xuICBsZXQgYXNzb2NpYXRlZCA9IExJTktFRC5nZXQocGFyZW50KTtcblxuICBpZiAoYXNzb2NpYXRlZCkge1xuICAgIGFzc29jaWF0ZWQuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgIGl0ZW1bV0lMTF9EUk9QXSgpO1xuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaWREZXN0cm95QXNzb2NpYXRlZChwYXJlbnQ6IG9iamVjdCkge1xuICBsZXQgYXNzb2NpYXRlZCA9IExJTktFRC5nZXQocGFyZW50KTtcblxuICBpZiAoYXNzb2NpYXRlZCkge1xuICAgIGFzc29jaWF0ZWQuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgIGl0ZW1bRElEX0RST1BdKCk7XG4gICAgICBhc3NvY2lhdGVkIS5kZWxldGUoaXRlbSk7XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlc3RydWN0b3IodmFsdWU6IG9iamVjdCk6IERyb3Age1xuICBsZXQgZCA9IERFU1RSVUNUT1JTLmdldCh2YWx1ZSk7XG5cbiAgaWYgKCFkKSB7XG4gICAgaWYgKGlzRGVzdHJveWFibGUodmFsdWUpKSB7XG4gICAgICBkID0gbmV3IERlc3Ryb3lhYmxlRGVzdHJ1Y3Rvcih2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChpc1N0cmluZ0Rlc3Ryb3lhYmxlKHZhbHVlKSkge1xuICAgICAgZCA9IG5ldyBTdHJpbmdEZXN0cm95YWJsZURlc3RydWN0b3IodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkID0gbmV3IFNpbXBsZURlc3RydWN0b3IodmFsdWUpO1xuICAgIH1cblxuICAgIERFU1RSVUNUT1JTLnNldCh2YWx1ZSwgZCk7XG4gIH1cblxuICByZXR1cm4gZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNuYXBzaG90KHZhbHVlczogU2V0PERyb3A+KTogRHJvcCB7XG4gIHJldHVybiBuZXcgU25hcHNob3REZXN0cnVjdG9yKHZhbHVlcyk7XG59XG5cbmNsYXNzIFNuYXBzaG90RGVzdHJ1Y3RvciBpbXBsZW1lbnRzIERyb3Age1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGRlc3RydWN0b3JzOiBTZXQ8RHJvcD4pIHt9XG5cbiAgW1dJTExfRFJPUF0oKSB7XG4gICAgdGhpcy5kZXN0cnVjdG9ycy5mb3JFYWNoKGl0ZW0gPT4gaXRlbVtXSUxMX0RST1BdKCkpO1xuICB9XG5cbiAgW0RJRF9EUk9QXSgpIHtcbiAgICB0aGlzLmRlc3RydWN0b3JzLmZvckVhY2goaXRlbSA9PiBpdGVtW0RJRF9EUk9QXSgpKTtcbiAgfVxuXG4gIGdldCBbQ0hJTERSRU5dKCk6IEl0ZXJhYmxlPERyb3A+IHtcbiAgICByZXR1cm4gdGhpcy5kZXN0cnVjdG9ycztcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnU25hcHNob3REZXN0cnVjdG9yJztcbiAgfVxufVxuXG5jbGFzcyBEZXN0cm95YWJsZURlc3RydWN0b3IgaW1wbGVtZW50cyBEcm9wIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBpbm5lcjogU3ltYm9sRGVzdHJveWFibGUpIHt9XG5cbiAgW1dJTExfRFJPUF0oKSB7XG4gICAgd2lsbERlc3Ryb3lBc3NvY2lhdGVkKHRoaXMuaW5uZXIpO1xuICB9XG5cbiAgW0RJRF9EUk9QXSgpIHtcbiAgICB0aGlzLmlubmVyW0RFU1RST1ldKCk7XG4gICAgZGlkRGVzdHJveUFzc29jaWF0ZWQodGhpcy5pbm5lcik7XG4gIH1cblxuICBnZXQgW0NISUxEUkVOXSgpOiBJdGVyYWJsZTxEcm9wPiB7XG4gICAgcmV0dXJuIExJTktFRC5nZXQodGhpcy5pbm5lcikgfHwgW107XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ0Rlc3Ryb3lhYmxlRGVzdHJ1Y3Rvcic7XG4gIH1cbn1cblxuY2xhc3MgU3RyaW5nRGVzdHJveWFibGVEZXN0cnVjdG9yIGltcGxlbWVudHMgRHJvcCB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgaW5uZXI6IERlc3Ryb3lhYmxlKSB7fVxuXG4gIFtXSUxMX0RST1BdKCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5pbm5lci53aWxsRGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5pbm5lci53aWxsRGVzdHJveSgpO1xuICAgIH1cbiAgICB3aWxsRGVzdHJveUFzc29jaWF0ZWQodGhpcy5pbm5lcik7XG4gIH1cblxuICBbRElEX0RST1BdKCkge1xuICAgIHRoaXMuaW5uZXIuZGVzdHJveSgpO1xuICAgIGRpZERlc3Ryb3lBc3NvY2lhdGVkKHRoaXMuaW5uZXIpO1xuICB9XG5cbiAgZ2V0IFtDSElMRFJFTl0oKTogSXRlcmFibGU8RHJvcD4ge1xuICAgIHJldHVybiBMSU5LRUQuZ2V0KHRoaXMuaW5uZXIpIHx8IFtdO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdTdHJpbmdEZXN0cm95YWJsZURlc3RydWN0b3InO1xuICB9XG59XG5cbmNsYXNzIFNpbXBsZURlc3RydWN0b3IgaW1wbGVtZW50cyBEcm9wIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBpbm5lcjogb2JqZWN0KSB7fVxuXG4gIFtXSUxMX0RST1BdKCkge1xuICAgIHdpbGxEZXN0cm95QXNzb2NpYXRlZCh0aGlzLmlubmVyKTtcbiAgfVxuXG4gIFtESURfRFJPUF0oKSB7XG4gICAgZGlkRGVzdHJveUFzc29jaWF0ZWQodGhpcy5pbm5lcik7XG4gIH1cblxuICBnZXQgW0NISUxEUkVOXSgpOiBJdGVyYWJsZTxEcm9wPiB7XG4gICAgcmV0dXJuIExJTktFRC5nZXQodGhpcy5pbm5lcikgfHwgW107XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ1NpbXBsZURlc3RydWN0b3InO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBMaXN0Q29udGVudHNEZXN0cnVjdG9yIGltcGxlbWVudHMgRHJvcCB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgaW5uZXI6IExpbmtlZExpc3Q8TGlua2VkTGlzdE5vZGU+KSB7fVxuXG4gIFtXSUxMX0RST1BdKCkge1xuICAgIHRoaXMuaW5uZXIuZm9yRWFjaE5vZGUoZCA9PiBkZXN0cnVjdG9yKGQpW1dJTExfRFJPUF0oKSk7XG4gIH1cblxuICBbRElEX0RST1BdKCkge1xuICAgIHRoaXMuaW5uZXIuZm9yRWFjaE5vZGUoZCA9PiBkZXN0cnVjdG9yKGQpW0RJRF9EUk9QXSgpKTtcbiAgfVxuXG4gIGdldCBbQ0hJTERSRU5dKCk6IEl0ZXJhYmxlPERyb3A+IHtcbiAgICBsZXQgb3V0OiBEcm9wW10gPSBbXTtcbiAgICB0aGlzLmlubmVyLmZvckVhY2hOb2RlKGQgPT4gb3V0LnB1c2goLi4uZGVzdHJ1Y3RvcihkKVtDSElMRFJFTl0pKTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdMaXN0Q29udGVudHNEZXN0cnVjdG9yJztcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIERlYnVnTm9kZSB7XG4gIGlubmVyOiBvYmplY3Q7XG4gIGNoaWxkcmVuOiBEZWJ1Z05vZGVbXSB8IG51bGw7XG4gIGhhc0Ryb3A6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWJ1Z0Ryb3BUcmVlKGlubmVyOiBvYmplY3QpOiBEZWJ1Z05vZGUge1xuICBsZXQgaGFzRHJvcCA9IGlzRHJvcChpbm5lcik7XG4gIGxldCByYXdDaGlsZHJlbiA9IExJTktFRC5nZXQoaW5uZXIpIHx8IG51bGw7XG4gIGxldCBjaGlsZHJlbjogRGVidWdOb2RlW10gfCBudWxsID0gbnVsbDtcblxuICBpZiAocmF3Q2hpbGRyZW4pIHtcbiAgICBjaGlsZHJlbiA9IFtdO1xuICAgIGZvciAobGV0IGNoaWxkIG9mIHJhd0NoaWxkcmVuKSB7XG4gICAgICBjaGlsZHJlbi5wdXNoKGRlYnVnRHJvcFRyZWUoY2hpbGQpKTtcbiAgICB9XG4gIH1cblxuICBsZXQgb2JqID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgb2JqLmlubmVyID0gaW5uZXI7XG4gIGlmIChjaGlsZHJlbikge1xuICAgIG9iai5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9XG4gIG9iai5oYXNEcm9wID0gaGFzRHJvcDtcbiAgcmV0dXJuIG9iajtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByaW50RHJvcFRyZWUoaW5uZXI6IG9iamVjdCkge1xuICBwcmludERyb3AoZGVzdHJ1Y3Rvcihpbm5lcikpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJpbnREcm9wKGlubmVyOiBEcm9wKSB7XG4gIGNvbnNvbGUuZ3JvdXAoU3RyaW5nKGlubmVyKSk7XG5cbiAgY29uc29sZS5sb2coaW5uZXIpO1xuXG4gIGxldCBjaGlsZHJlbiA9IGlubmVyW0NISUxEUkVOXSB8fCBudWxsO1xuICBpZiAoY2hpbGRyZW4pIHtcbiAgICBmb3IgKGxldCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgICAgcHJpbnREcm9wKGNoaWxkKTtcbiAgICB9XG4gIH1cblxuICBjb25zb2xlLmdyb3VwRW5kKCk7XG59XG5cbmlmIChMT0NBTF9ERUJVRyAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAod2luZG93IGFzIGFueSkuUFJJTlRfRFJPUCA9IHByaW50RHJvcFRyZWU7XG59XG4iLCJpbXBvcnQgeyBPcHRpb24gfSBmcm9tICcuL3BsYXRmb3JtLXV0aWxzJztcbmltcG9ydCB7IFdJTExfRFJPUCwgRElEX0RST1AsIGRlc3RydWN0b3IsIENISUxEUkVOIH0gZnJvbSAnLi9saWZldGltZXMnO1xuaW1wb3J0IHsgRHJvcCB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIExpbmtlZExpc3ROb2RlIHtcbiAgbmV4dDogT3B0aW9uPExpbmtlZExpc3ROb2RlPjtcbiAgcHJldjogT3B0aW9uPExpbmtlZExpc3ROb2RlPjtcbn1cblxuZXhwb3J0IGNsYXNzIExpc3ROb2RlPFQ+IGltcGxlbWVudHMgTGlua2VkTGlzdE5vZGUge1xuICBwdWJsaWMgbmV4dDogT3B0aW9uPExpc3ROb2RlPFQ+PiA9IG51bGw7XG4gIHB1YmxpYyBwcmV2OiBPcHRpb248TGlzdE5vZGU8VD4+ID0gbnVsbDtcbiAgcHVibGljIHZhbHVlOiBUO1xuXG4gIGNvbnN0cnVjdG9yKHZhbHVlOiBUKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG59XG5cbi8vIHdlIGFyZSB1bmFibGUgdG8gZXhwcmVzcyB0aGUgY29uc3RyYWludCB0aGF0IFQncyAucHJldiBhbmQgLm5leHQgYXJlXG4vLyB0aGVtc2VsdmVzIFQuIEhvd2V2ZXIsIGl0IHdpbGwgYWx3YXlzIGJlIHRydWUsIHNvIHRydXN0IHVzLlxudHlwZSB0cnVzdCA9IGFueTtcblxuZXhwb3J0IGNsYXNzIExpbmtlZExpc3Q8VCBleHRlbmRzIExpbmtlZExpc3ROb2RlPiBpbXBsZW1lbnRzIFNsaWNlPFQ+LCBEcm9wIHtcbiAgcHJpdmF0ZSBfaGVhZCE6IE9wdGlvbjxUPjtcbiAgcHJpdmF0ZSBfdGFpbCE6IE9wdGlvbjxUPjtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNsZWFyKCk7XG4gIH1cblxuICBoZWFkKCk6IE9wdGlvbjxUPiB7XG4gICAgcmV0dXJuIHRoaXMuX2hlYWQ7XG4gIH1cblxuICB0YWlsKCk6IE9wdGlvbjxUPiB7XG4gICAgcmV0dXJuIHRoaXMuX3RhaWw7XG4gIH1cblxuICBjbGVhcigpIHtcbiAgICB0aGlzLl9oZWFkID0gdGhpcy5fdGFpbCA9IG51bGw7XG4gIH1cblxuICB0b0FycmF5KCk6IFRbXSB7XG4gICAgbGV0IG91dDogVFtdID0gW107XG4gICAgdGhpcy5mb3JFYWNoTm9kZShuID0+IG91dC5wdXNoKG4pKTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbiAgbmV4dE5vZGUobm9kZTogVCk6IFQge1xuICAgIHJldHVybiBub2RlLm5leHQgYXMgdHJ1c3Q7XG4gIH1cblxuICBmb3JFYWNoTm9kZShjYWxsYmFjazogKG5vZGU6IFQpID0+IHZvaWQpIHtcbiAgICBsZXQgbm9kZSA9IHRoaXMuX2hlYWQ7XG5cbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgY2FsbGJhY2sobm9kZSBhcyB0cnVzdCk7XG4gICAgICBub2RlID0gbm9kZS5uZXh0IGFzIHRydXN0O1xuICAgIH1cbiAgfVxuXG4gIGluc2VydEJlZm9yZShub2RlOiBULCByZWZlcmVuY2U6IE9wdGlvbjxUPiA9IG51bGwpOiBUIHtcbiAgICBpZiAocmVmZXJlbmNlID09PSBudWxsKSByZXR1cm4gdGhpcy5hcHBlbmQobm9kZSk7XG5cbiAgICBpZiAocmVmZXJlbmNlLnByZXYpIHJlZmVyZW5jZS5wcmV2Lm5leHQgPSBub2RlO1xuICAgIGVsc2UgdGhpcy5faGVhZCA9IG5vZGU7XG5cbiAgICBub2RlLnByZXYgPSByZWZlcmVuY2UucHJldjtcbiAgICBub2RlLm5leHQgPSByZWZlcmVuY2U7XG4gICAgcmVmZXJlbmNlLnByZXYgPSBub2RlO1xuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBhcHBlbmQobm9kZTogVCk6IFQge1xuICAgIGxldCB0YWlsID0gdGhpcy5fdGFpbDtcblxuICAgIGlmICh0YWlsKSB7XG4gICAgICB0YWlsLm5leHQgPSBub2RlO1xuICAgICAgbm9kZS5wcmV2ID0gdGFpbDtcbiAgICAgIG5vZGUubmV4dCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2hlYWQgPSBub2RlO1xuICAgIH1cblxuICAgIHJldHVybiAodGhpcy5fdGFpbCA9IG5vZGUpO1xuICB9XG5cbiAgcmVtb3ZlKG5vZGU6IFQpOiBUIHtcbiAgICBpZiAobm9kZS5wcmV2KSBub2RlLnByZXYubmV4dCA9IG5vZGUubmV4dDtcbiAgICBlbHNlIHRoaXMuX2hlYWQgPSBub2RlLm5leHQgYXMgdHJ1c3Q7XG5cbiAgICBpZiAobm9kZS5uZXh0KSBub2RlLm5leHQucHJldiA9IG5vZGUucHJldjtcbiAgICBlbHNlIHRoaXMuX3RhaWwgPSBub2RlLnByZXYgYXMgdHJ1c3Q7XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIFtXSUxMX0RST1BdKCkge1xuICAgIHRoaXMuZm9yRWFjaE5vZGUoZCA9PiBkZXN0cnVjdG9yKGQpW1dJTExfRFJPUF0oKSk7XG4gIH1cblxuICBbRElEX0RST1BdKCkge1xuICAgIHRoaXMuZm9yRWFjaE5vZGUoZCA9PiBkZXN0cnVjdG9yKGQpW0RJRF9EUk9QXSgpKTtcbiAgfVxuXG4gIGdldCBbQ0hJTERSRU5dKCk6IEl0ZXJhYmxlPERyb3A+IHtcbiAgICBsZXQgb3V0OiBEcm9wW10gPSBbXTtcbiAgICB0aGlzLmZvckVhY2hOb2RlKGQgPT4gb3V0LnB1c2goLi4uZGVzdHJ1Y3RvcihkKVtDSElMRFJFTl0pKTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2xpY2U8VCBleHRlbmRzIExpbmtlZExpc3ROb2RlPiB7XG4gIGhlYWQoKTogT3B0aW9uPFQ+O1xuICB0YWlsKCk6IE9wdGlvbjxUPjtcbiAgbmV4dE5vZGUobm9kZTogVCk6IE9wdGlvbjxUPjtcbiAgZm9yRWFjaE5vZGUoY2FsbGJhY2s6IChub2RlOiBUKSA9PiB2b2lkKTogdm9pZDtcbiAgdG9BcnJheSgpOiBUW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2xvbmVhYmxlTGlzdE5vZGUgZXh0ZW5kcyBMaW5rZWRMaXN0Tm9kZSB7XG4gIGNsb25lKCk6IHRoaXM7XG59XG5cbmV4cG9ydCBjbGFzcyBMaXN0U2xpY2U8VCBleHRlbmRzIExpbmtlZExpc3ROb2RlPiBpbXBsZW1lbnRzIFNsaWNlPFQ+IHtcbiAgcHJpdmF0ZSBfaGVhZDogT3B0aW9uPFQ+O1xuICBwcml2YXRlIF90YWlsOiBPcHRpb248VD47XG5cbiAgY29uc3RydWN0b3IoaGVhZDogT3B0aW9uPFQ+LCB0YWlsOiBPcHRpb248VD4pIHtcbiAgICB0aGlzLl9oZWFkID0gaGVhZDtcbiAgICB0aGlzLl90YWlsID0gdGFpbDtcbiAgfVxuXG4gIGZvckVhY2hOb2RlKGNhbGxiYWNrOiAobm9kZTogVCkgPT4gdm9pZCkge1xuICAgIGxldCBub2RlID0gdGhpcy5faGVhZDtcblxuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBjYWxsYmFjayhub2RlKTtcbiAgICAgIG5vZGUgPSB0aGlzLm5leHROb2RlKG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGhlYWQoKTogT3B0aW9uPFQ+IHtcbiAgICByZXR1cm4gdGhpcy5faGVhZDtcbiAgfVxuXG4gIHRhaWwoKTogT3B0aW9uPFQ+IHtcbiAgICByZXR1cm4gdGhpcy5fdGFpbDtcbiAgfVxuXG4gIHRvQXJyYXkoKTogVFtdIHtcbiAgICBsZXQgb3V0OiBUW10gPSBbXTtcbiAgICB0aGlzLmZvckVhY2hOb2RlKG4gPT4gb3V0LnB1c2gobikpO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cblxuICBuZXh0Tm9kZShub2RlOiBUKTogT3B0aW9uPFQ+IHtcbiAgICBpZiAobm9kZSA9PT0gdGhpcy5fdGFpbCkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIG5vZGUubmV4dCBhcyBUO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBFTVBUWV9TTElDRSA9IG5ldyBMaXN0U2xpY2UobnVsbCwgbnVsbCk7XG4iLCJjb25zdCB7IGtleXM6IG9iaktleXMgfSA9IE9iamVjdDtcblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbjxULCBVPihvYmo6IFQsIGFzc2lnbm1lbnRzOiBVKTogVCAmIFU7XG5leHBvcnQgZnVuY3Rpb24gYXNzaWduPFQsIFUsIFY+KG9iajogVCwgYTogVSwgYjogVik6IFQgJiBVICYgVjtcbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ248VCwgVSwgViwgVz4ob2JqOiBULCBhOiBVLCBiOiBWLCBjOiBXKTogVCAmIFUgJiBWICYgVztcbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ248VCwgVSwgViwgVywgWD4ob2JqOiBULCBhOiBVLCBiOiBWLCBjOiBXLCBkOiBYKTogVCAmIFUgJiBWICYgVyAmIFg7XG5leHBvcnQgZnVuY3Rpb24gYXNzaWduPFQsIFUsIFYsIFcsIFgsIFk+KFxuICBvYmo6IFQsXG4gIGE6IFUsXG4gIGI6IFYsXG4gIGM6IFcsXG4gIGQ6IFgsXG4gIGU6IFlcbik6IFQgJiBVICYgViAmIFcgJiBYICYgWTtcbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ248VCwgVSwgViwgVywgWCwgWSwgWj4oXG4gIG9iajogVCxcbiAgYTogVSxcbiAgYjogVixcbiAgYzogVyxcbiAgZDogWCxcbiAgZTogWSxcbiAgZjogWlxuKTogVCAmIFUgJiBWICYgVyAmIFggJiBZICYgWjtcbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0OiBhbnksIC4uLmFyZ3M6IGFueVtdKTogYW55O1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbihvYmo6IGFueSkge1xuICBmb3IgKGxldCBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBhc3NpZ25tZW50ID0gYXJndW1lbnRzW2ldO1xuICAgIGlmIChhc3NpZ25tZW50ID09PSBudWxsIHx8IHR5cGVvZiBhc3NpZ25tZW50ICE9PSAnb2JqZWN0JykgY29udGludWU7XG4gICAgbGV0IGtleXMgPSBvYmpLZXlzKGFzc2lnbm1lbnQpO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwga2V5cy5sZW5ndGg7IGorKykge1xuICAgICAgbGV0IGtleSA9IGtleXNbal07XG4gICAgICBvYmpba2V5XSA9IGFzc2lnbm1lbnRba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbGxOdWxsczxUPihjb3VudDogbnVtYmVyKTogVFtdIHtcbiAgbGV0IGFyciA9IG5ldyBBcnJheShjb3VudCk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgYXJyW2ldID0gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBhcnI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWx1ZXM8VD4ob2JqOiB7IFtzOiBzdHJpbmddOiBUIH0pOiBUW10ge1xuICBjb25zdCB2YWxzID0gW107XG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIHZhbHMucHVzaChvYmpba2V5XSk7XG4gIH1cbiAgcmV0dXJuIHZhbHM7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gc3RyaXAoc3RyaW5nczogVGVtcGxhdGVTdHJpbmdzQXJyYXksIC4uLmFyZ3M6IHVua25vd25bXSkge1xuICBsZXQgb3V0ID0gJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaW5ncy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBzdHJpbmcgPSBzdHJpbmdzW2ldO1xuICAgIGxldCBkeW5hbWljID0gYXJnc1tpXSAhPT0gdW5kZWZpbmVkID8gU3RyaW5nKGFyZ3NbaV0pIDogJyc7XG5cbiAgICBvdXQgKz0gYCR7c3RyaW5nfSR7ZHluYW1pY31gO1xuICB9XG5cbiAgbGV0IGxpbmVzID0gb3V0LnNwbGl0KCdcXG4nKTtcblxuICB3aGlsZSAobGluZXMubGVuZ3RoICYmIGxpbmVzWzBdLm1hdGNoKC9eXFxzKiQvKSkge1xuICAgIGxpbmVzLnNoaWZ0KCk7XG4gIH1cblxuICB3aGlsZSAobGluZXMubGVuZ3RoICYmIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLm1hdGNoKC9eXFxzKiQvKSkge1xuICAgIGxpbmVzLnBvcCgpO1xuICB9XG5cbiAgbGV0IG1pbiA9IEluZmluaXR5O1xuXG4gIGZvciAobGV0IGxpbmUgb2YgbGluZXMpIHtcbiAgICBsZXQgbGVhZGluZyA9IGxpbmUubWF0Y2goL15cXHMqLykhWzBdLmxlbmd0aDtcblxuICAgIG1pbiA9IE1hdGgubWluKG1pbiwgbGVhZGluZyk7XG4gIH1cblxuICBsZXQgc3RyaXBwZWQgPSBbXTtcblxuICBmb3IgKGxldCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgc3RyaXBwZWQucHVzaChsaW5lLnNsaWNlKG1pbikpO1xuICB9XG5cbiAgcmV0dXJuIHN0cmlwcGVkLmpvaW4oJ1xcbicpO1xufVxuIiwiaW1wb3J0IHsgZXhoYXVzdGVkIH0gZnJvbSAnLi9wbGF0Zm9ybS11dGlscyc7XG5pbXBvcnQgeyBMT0NBTF9ERUJVRyB9IGZyb20gJ0BnbGltbWVyL2xvY2FsLWRlYnVnLWZsYWdzJztcblxubGV0IGNoZWNrSW50OiB1bmRlZmluZWQgfCAoKG51bTogbnVtYmVyLCBtaW4/OiBudW1iZXIsIG1heD86IG51bWJlcikgPT4gdm9pZCk7XG5cbmlmIChMT0NBTF9ERUJVRykge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdmFyLHZhcnMtb24tdG9wXG4gIGNoZWNrSW50ID0gKG51bTogbnVtYmVyLCBtaW4gPSAtMjE0NzQ4MzY0OCwgbWF4ID0gMjE0NzQ4MzY0NykgPT4ge1xuICAgIGlmICghaXNJbnQobnVtLCBtaW4sIG1heCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgJHtudW19IHRvIGJlIGFuIGludGVnZXIgYmV0d2VlbiAke21pbn0gdG8gJHttYXh9YCk7XG4gICAgfVxuICB9O1xufVxuXG4vKlxuRW5jb2Rpbmcgbm90ZXNcblxuZmlyc3RcbjIgYml0cyAgICBzdGFydCAgICAgICAgZW5kXG4wIDEgICAgICAgMTA3Mzc0MTgyNCAgIDIxNDc0ODM2NDcgICBkaXJlY3QgbmVnYXRpdmUgb3IgYm9vbGVhbiBvciBudWxsIG9yIHVuZGVmaW5lZFxuMCAwICAgICAgIDAgICAgICAgICAgICAxMDczNzQxODIzICAgZGlyZWN0IHBvc2l0aXZlXG4xIDEgICAgICAgLTEgICAgICAgICAgIC0xMDczNzQxODI0ICBzdHJpbmcgaW5kZXhcbjEgMCAgICAgICAtMTA3Mzc0MTgyNSAgLTIxNDc0ODM2NDggIG51bWJlciBpbmRleFxuXG5TaW5jZSBmaXJzdCBiaXQgaXMgdGhlIHNpZ24gYml0IHRoZW5cblxuZW5jb2RlZCA+PSAwICBpcyBhbGwgZGlyZWN0bHkgZW5jb2RlZCB2YWx1ZXNcbmVuY29kZWQgPCAwICBpcyBhbGwgaW5kaXJlY3QgZW5jb2RlZCB2YWx1ZXMgKGVuY29kZWQgaW5kZXhlcylcblxuRm9yIGRpcmVjdGx5IGVuY29kZWQgdmFsdWVzXG5lbmNvZGVkICAgICAgZGVjb2RlZFxuMCAgICAgICAgICAgIDBcbi4uLiAgICAgICAgICAuLi5cbjEwNzM3NDE4MjMgICAxMDczNzQxODIzXG4xMDczNzQxODI0ICAgZmFsc2VcbjEwNzM3NDE4MjUgICB0cnVlXG4xMDczNzQxODI2ICAgbnVsbFxuMTA3Mzc0MTgyNyAgIHVuZGVmaW5lZFxuMTA3Mzc0MTgyOCAgIC0xXG4uLi4gICAgICAgICAgLi4uXG4yMTQ3NDgzNjQ3ICAgLTEwNzM3NDE4MjBcblxuZm9yIHN0YWNrIGhhbmRsZXNcbndlIG1hcCBqcyBpbmRleCAwIHRvIDIxNDc0ODM2NDcgb250byAtMSB0byAtMjE0NzQ4MzY0OFxuXG5mb3IgY29uc3RhbnQgaGFuZGxlc1xud2UgbWFwIHN0cmluZyBpbmRleCAwIHRvIDEwNzM3NDE4MjMgb250byAtMSB0byAtMTA3Mzc0MTgyNFxud2UgbWFwIG51bWJlciBpbmRleCAwIHRvIDEwNzM3NDE4MjMgb250byAtMTA3Mzc0MTgyNSB0byAtMjE0NzQ4MzY0OFxuKi9cblxuLyoqXG4gKiBJbW1lZGlhdGVzIHVzZSB0aGUgcG9zaXRpdmUgaGFsZiBvZiAzMiBiaXRzIDAgdGhyb3VnaCAyMTQ3NDgzNjQ3ICgweDdmZmZmZmZmKVxuICogbGVhdmluZyB0aGUgbmVnYXRpdmUgaGFsZiBmb3IgaGFuZGxlcyAtMSB0aHJvdWdoIC0yMTQ3NDgzNjQ4LlxuICovXG5leHBvcnQgY29uc3QgZW51bSBJbW1lZGlhdGVDb25zdGFudHMge1xuICAvKipcbiAgICogMzEgYml0cyBjYW4gZW5jb2RlIDJeMzEgdmFsdWVzXG4gICAqL1xuICBJTU1FRElBVEVfTEVOR1RIID0gMiAqKiAzMSxcblxuICAvKipcbiAgICogTWluIGVuY29kZWQgaW1tZWRpYXRlIGlzIG1pbiBwb3NpdGl2ZVxuICAgKi9cbiAgTUlOX0lNTUVESUFURSA9IDAsXG5cbiAgLyoqXG4gICAqIE1heCBlbmNvZGVkIGltbWVkaWF0ZSBpcyB0aGUgbWF4IHBvc2l0aXZlIDMyIGJpdCBzaWduZWQgaW50XG4gICAqL1xuICBNQVhfSU1NRURJQVRFID0gSU1NRURJQVRFX0xFTkdUSCAtIDEsXG5cbiAgLyoqXG4gICAqIFRoZSBlbmNvZGluZyBvZiBmYWxzZS5cbiAgICogRmFsc2UgaXMgdGhlIHN0YXJ0IG9mIHRoZSBzZWNvbmQgaGFsZiBvZiAzMSBiaXRzXG4gICAqL1xuICBGQUxTRSA9IElNTUVESUFURV9MRU5HVEggLyAyLFxuXG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBpbnQgdGhhdCBjYW4gYmUgZGlyZWN0bHkgZW5jb2RlZCB2cyBhIGhhbmRsZS5cbiAgICpcbiAgICogVGhlIGxhc3QgcG9zaXRpdmUgaW50IGlzIGp1c3QgYmVmb3JlIEZBTFNFLlxuICAgKi9cbiAgTUFYX0lOVCA9IEZBTFNFIC0gMSxcblxuICAvKipcbiAgICogVGhlIGVuY29kaW5nIG9mIHRydWVcbiAgICovXG4gIFRSVUUgPSBGQUxTRSArIDEsXG5cbiAgLyoqXG4gICAqIFRoZSBlbmNvZGluZyBvZiBudWxsXG4gICAqL1xuICBOVUxMID0gVFJVRSArIDEsXG5cbiAgLyoqXG4gICAqIFRoZSBlbmNvZGluZyBvZiB1bmRlZmluZWRcbiAgICovXG4gIFVOREVGSU5FRCA9IE5VTEwgKyAxLFxuXG4gIC8qKlxuICAgKiBFbmNvZGVkIC0xXG4gICAqXG4gICAqIEVuY29kZWQganVzdCBhZnRlciBVTkRFRklORURcbiAgICovXG4gIE5FR0FUSVZFX09ORSA9IFVOREVGSU5FRCArIDEsXG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIHRvIHN1YnN0cmFjdCBhIG5lZ2F0aXZlIGZyb20gdG8gZGVjb2RlIG9yIGVuY29kZSBpdC5cbiAgICpcbiAgICogTkVHQVRJVkVfT05FICAgICAgPT0gTkVHQVRJVkVfQkFTRSAtIC0xICAgICAgICAgICAgID09IGVuY29kZUltbWVkaWF0ZSgtMSlcbiAgICogTUFYX0lNTUVESUFURSAgICAgPT0gTkVHQVRJVkVfQkFTRSAtIE1JTl9JTlQgICAgICAgID09IGVuY29kZUltbWVkaWF0ZShNSU5fSU5UKVxuICAgKiAtMSAgICAgICAgICAgICAgICA9PSBORUdBVElWRV9CQVNFIC0gTkVHQVRJVkVfT05FICAgPT0gZGVjb2RlSW1tZWRpYXRlKE5FR0FUSVZFX09ORSlcbiAgICogTUlOX0lOVCAgICAgICAgICAgPT0gTkVHQVRJVkVfQkFTRSAtIE1BWF9JTU1FRElBVEUgID09IGRlY29kZUltbWVkaWF0ZShNQVhfSU1NRURJQVRFKVxuICAgKi9cbiAgTkVHQVRJVkVfQkFTRSA9IE5FR0FUSVZFX09ORSAtIDEsXG5cbiAgLyoqXG4gICAqIFRoZSBtaW5pbXVtIGludCB0aGF0IGNhbiBiZSBkaXJlY3RseSBlbmNvZGVkIHZzIGEgaGFuZGxlLlxuICAgKi9cbiAgTUlOX0lOVCA9IE5FR0FUSVZFX0JBU0UgLSBNQVhfSU1NRURJQVRFLFxufVxuXG4vKipcbiAqIFRoZSBjb21waWxlciBjb25zdGFudHMgZGl2aWRlIHRoZSBoYW5kbGVzIGludG8gdHdvIGhhbHZlcyBzdHJpbmdzIGFuZCBudW1iZXJzXG4gKiB3aGlsZSBvbiB0aGUgc3RhY2ssIHRoZXJlIGlzIG9ubHkgb25lIGFycmF5IG9mIGpzIHZhbHVlcy5cbiAqL1xuZXhwb3J0IGNvbnN0IGVudW0gSGFuZGxlQ29uc3RhbnRzIHtcbiAgSEFORExFX0xFTkdUSCA9IDIgKiogMzEsXG4gIE1BWF9JTkRFWCA9IEhBTkRMRV9MRU5HVEggLSAxLFxuICBNQVhfSEFORExFID0gLTEsXG4gIE1JTl9IQU5ETEUgPSAtMSAtIE1BWF9JTkRFWCxcbiAgU1RSSU5HX0hBTkRMRV9MRU5HVEggPSBIQU5ETEVfTEVOR1RIIC8gMixcbiAgTlVNQkVSX0hBTkRMRV9MRU5HVEggPSBIQU5ETEVfTEVOR1RIIC0gU1RSSU5HX0hBTkRMRV9MRU5HVEgsXG4gIFNUUklOR19NQVhfSU5ERVggPSBTVFJJTkdfSEFORExFX0xFTkdUSCAtIDEsXG4gIE5VTUJFUl9NQVhfSU5ERVggPSBOVU1CRVJfSEFORExFX0xFTkdUSCAtIDEsXG4gIFNUUklOR19NQVhfSEFORExFID0gTUFYX0hBTkRMRSxcbiAgU1RSSU5HX01JTl9IQU5ETEUgPSBTVFJJTkdfTUFYX0hBTkRMRSAtIFNUUklOR19NQVhfSU5ERVgsXG4gIE5VTUJFUl9NQVhfSEFORExFID0gU1RSSU5HX01JTl9IQU5ETEUgLSAxLFxuICBOVU1CRVJfTUlOX0hBTkRMRSA9IE5VTUJFUl9NQVhfSEFORExFIC0gTlVNQkVSX01BWF9JTkRFWCxcbn1cblxuLyoqXG4gKiBFbmNvZGVzIGEgdmFsdWUgdGhhdCBjYW4gYmUgc3RvcmVkIGRpcmVjdGx5IGluc3RlYWQgb2YgYmVpbmcgYSBoYW5kbGUuXG4gKlxuICogSW1tZWRpYXRlcyB1c2UgdGhlIHBvc2l0aXZlIGhhbGYgb2YgMzJiaXRzXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gdGhlIHZhbHVlIHRvIGJlIGVuY29kZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVJbW1lZGlhdGUodmFsdWU6IG51bGwgfCB1bmRlZmluZWQgfCBib29sZWFuIHwgbnVtYmVyKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKExPQ0FMX0RFQlVHKSB7XG4gICAgICBjaGVja0ludCEodmFsdWUsIEltbWVkaWF0ZUNvbnN0YW50cy5NSU5fSU5ULCBJbW1lZGlhdGVDb25zdGFudHMuTUFYX0lOVCk7XG4gICAgfVxuICAgIC8vIG1hcCAtMSB0byAtMTA3Mzc0MTgyMCBvbnRvIDEwNzM3NDE4MjggdG8gMjE0NzQ4MzY0N1xuICAgIC8vIDEwNzM3NDE4MjcgLSAoLTEpID09IDEwNzM3NDE4MjhcbiAgICAvLyAxMDczNzQxODI3IC0gKC0xMDczNzQxODIwKSA9PSAyMTQ3NDgzNjQ3XG4gICAgLy8gcG9zaXRpdmUgaXQgc3RheXMgYXMgaXNcbiAgICAvLyAwIC0gMTA3Mzc0MTgyM1xuICAgIHJldHVybiB2YWx1ZSA8IDAgPyBJbW1lZGlhdGVDb25zdGFudHMuTkVHQVRJVkVfQkFTRSAtIHZhbHVlIDogdmFsdWU7XG4gIH1cbiAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgIHJldHVybiBJbW1lZGlhdGVDb25zdGFudHMuRkFMU0U7XG4gIH1cbiAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIEltbWVkaWF0ZUNvbnN0YW50cy5UUlVFO1xuICB9XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBJbW1lZGlhdGVDb25zdGFudHMuTlVMTDtcbiAgfVxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBJbW1lZGlhdGVDb25zdGFudHMuVU5ERUZJTkVEO1xuICB9XG4gIHJldHVybiBleGhhdXN0ZWQodmFsdWUpO1xufVxuXG4vKipcbiAqIERlY29kZXMgYW4gaW1tZWRpYXRlIGludG8gaXRzIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIHRoZSBlbmNvZGVkIGltbWVkaWF0ZSB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlSW1tZWRpYXRlKHZhbHVlOiBudW1iZXIpOiBudWxsIHwgdW5kZWZpbmVkIHwgYm9vbGVhbiB8IG51bWJlciB7XG4gIGlmIChMT0NBTF9ERUJVRykge1xuICAgIC8vIGV4cGVjdGVkIHZhbHVlIHRvIGJlIGNoZWNrZWQgYmVmb3JlIHRoaXNcbiAgICBjaGVja0ludCEodmFsdWUsIEltbWVkaWF0ZUNvbnN0YW50cy5NSU5fSU1NRURJQVRFLCBJbW1lZGlhdGVDb25zdGFudHMuTUFYX0lNTUVESUFURSk7XG4gIH1cbiAgaWYgKHZhbHVlID4gSW1tZWRpYXRlQ29uc3RhbnRzLk1BWF9JTlQpIHtcbiAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICBjYXNlIEltbWVkaWF0ZUNvbnN0YW50cy5GQUxTRTpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgY2FzZSBJbW1lZGlhdGVDb25zdGFudHMuVFJVRTpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlIEltbWVkaWF0ZUNvbnN0YW50cy5OVUxMOlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNhc2UgSW1tZWRpYXRlQ29uc3RhbnRzLlVOREVGSU5FRDpcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIG1hcCAxMDczNzQxODI4IHRvIDIxNDc0ODM2NDcgdG8gLTEgdG8gLTEwNzM3NDE4MjBcbiAgICAgICAgLy8gMTA3Mzc0MTgyNyAtIDEwNzM3NDE4MjggPT0gLTFcbiAgICAgICAgLy8gMTA3Mzc0MTgyNyAtIDIxNDc0ODM2NDcgPT0gLTEwNzM3NDE4MjBcbiAgICAgICAgcmV0dXJuIEltbWVkaWF0ZUNvbnN0YW50cy5ORUdBVElWRV9CQVNFIC0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBUcnVlIGlmIHRoZSBudW1iZXIgY2FuIGJlIHN0b3JlZCBkaXJlY3RseSBvciBmYWxzZSBpZiBpdCBuZWVkcyBhIGhhbmRsZS5cbiAqXG4gKiBUaGlzIGlzIHVzZWQgb24gYW55IG51bWJlciB0eXBlIHRvIHNlZSBpZiBpdCBjYW4gYmUgZGlyZWN0bHkgZW5jb2RlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU21hbGxJbnQobnVtOiBudW1iZXIpIHtcbiAgcmV0dXJuIGlzSW50KG51bSwgSW1tZWRpYXRlQ29uc3RhbnRzLk1JTl9JTlQsIEltbWVkaWF0ZUNvbnN0YW50cy5NQVhfSU5UKTtcbn1cblxuLyoqXG4gKiBUcnVlIGlmIHRoZSBlbmNvZGVkIGludDMyIG9wZXJhbmQgb3IgZW5jb2RlZCBzdGFjayBpbnQzMiBpcyBhIGhhbmRsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzSGFuZGxlKGVuY29kZWQ6IG51bWJlcikge1xuICBpZiAoTE9DQUxfREVCVUcpIHtcbiAgICAvLyB3ZSBleHBlY3QgdG8gb25seSB1c2UgdGhpcyBtZXRob2Qgd2hlbiB3ZSBhbHJlYWR5IGtub3cgaXQgaXMgYW4gaW50MzJcbiAgICAvLyBiZWNhdXNlIGl0IHdhcyBlbmNvZGVkIG9yIHJlYWQgZnJvbSB0aGUgSW50MzJBcnJheSBidWZmZXJcbiAgICBjaGVja0ludCEoZW5jb2RlZCk7XG4gIH1cbiAgcmV0dXJuIGVuY29kZWQgPCAwO1xufVxuXG4vKipcbiAqIEVuY29kZXMgYW4gaW5kZXggdG8gYW4gb3BlcmFuZCBvciBzdGFjayBoYW5kbGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVIYW5kbGUoXG4gIGluZGV4OiBudW1iZXIsXG4gIG1heEluZGV4OiBudW1iZXIgPSBIYW5kbGVDb25zdGFudHMuTUFYX0lOREVYLFxuICBtYXhIYW5kbGU6IG51bWJlciA9IEhhbmRsZUNvbnN0YW50cy5NQVhfSEFORExFXG4pIHtcbiAgaWYgKExPQ0FMX0RFQlVHKSB7XG4gICAgLy8gZXhwZWN0ZWQgdGhlIGluZGV4IHRvIGFscmVhZHkgYmUgYSBwb3NpdGl2ZSBpbnQgaW5kZXggZnJvbSBwdXNoaW5nIHRoZSB2YWx1ZVxuICAgIGNoZWNrSW50IShpbmRleCwgMCk7XG4gIH1cbiAgaWYgKGluZGV4ID4gbWF4SW5kZXgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGluZGV4ICR7aW5kZXh9IG92ZXJmbG93ZWQgcmFuZ2UgMCB0byAke21heEluZGV4fWApO1xuICB9XG4gIC8vIC0xIC0gMCA9PSAtMVxuICAvLyAtMSAtIDEwNzM3NDE4MjMgPT0gLTEwNzM3NDE4MjRcbiAgLy8gLTEwNzM3NDE4MjUgLSAwID09IC0xMDczNzQxODI1XG4gIC8vIC0xMDczNzQxODI1IC0gMTA3Mzc0MTgyMyA9PSAtMjE0NzQ4MzY0OFxuICByZXR1cm4gbWF4SGFuZGxlIC0gaW5kZXg7XG59XG5cbi8qKlxuICogRGVjb2RlcyB0aGUgaW5kZXggZnJvbSB0aGUgc3BlY2lmaWVkIG9wZXJhbmQgb3Igc3RhY2sgaGFuZGxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlSGFuZGxlKGhhbmRsZTogbnVtYmVyLCBtYXhIYW5kbGU6IG51bWJlciA9IEhhbmRsZUNvbnN0YW50cy5NQVhfSEFORExFKSB7XG4gIGlmIChMT0NBTF9ERUJVRykge1xuICAgIC8vIHdlIGV4cGVjdCB0byBiZSBkZWNvZGluZyBhIGVuY29kZWQgaW50MzIgb3BlcmFuZCBvciBlbmNvZGVkIGludDMyIG9uIHRoZSBzdGFja1xuICAgIGNoZWNrSW50IShoYW5kbGUsIEhhbmRsZUNvbnN0YW50cy5NSU5fSEFORExFLCBtYXhIYW5kbGUpO1xuICB9XG4gIC8vIC0xIC0gLTEgPT0gMFxuICAvLyAtMSAtIC0xMDczNzQxODI0ID09IDEwNzM3NDE4MjNcbiAgLy8gLTEwNzM3NDE4MjUgLSAtMTA3Mzc0MTgyNSA9PSAwXG4gIC8vIC0xMDczNzQxODI1IC0gLTIxNDc0ODM2NDggPT0gMTA3Mzc0MTgyM1xuICByZXR1cm4gbWF4SGFuZGxlIC0gaGFuZGxlO1xufVxuXG5mdW5jdGlvbiBpc0ludChudW06IG51bWJlciwgbWluOiBudW1iZXIsIG1heDogbnVtYmVyKTogYm9vbGVhbiB7XG4gIC8vIHRoaXMgaXMgdGhlIHNhbWUgYXMgTWF0aC5mbG9vcihudW0pID09PSBudW1cbiAgLy8gYWxzbyBOYU4gJSAxIGlzIE5hTiBhbmQgSW5maW5pdHkgJSAxIGlzIE5hTiBzbyBib3RoIHNob3VsZCBmYWlsXG4gIHJldHVybiBudW0gJSAxID09PSAwICYmIG51bSA+PSBtaW4gJiYgbnVtIDw9IG1heDtcbn1cbiIsImltcG9ydCB7IEhhbmRsZVJlc3VsdCwgVGVtcGxhdGUsIFRlbXBsYXRlT2ssIE9rSGFuZGxlLCBFcnJIYW5kbGUgfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcblxuZXhwb3J0IGZ1bmN0aW9uIHVud3JhcEhhbmRsZShoYW5kbGU6IEhhbmRsZVJlc3VsdCk6IG51bWJlciB7XG4gIGlmICh0eXBlb2YgaGFuZGxlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBoYW5kbGU7XG4gIH0gZWxzZSB7XG4gICAgbGV0IGVycm9yID0gaGFuZGxlLmVycm9yc1swXTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvbXBpbGUgRXJyb3I6ICR7ZXJyb3IucHJvYmxlbX0gQCAke2Vycm9yLnNwYW4uc3RhcnR9Li4ke2Vycm9yLnNwYW4uZW5kfWApO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bndyYXBUZW1wbGF0ZTxNPih0ZW1wbGF0ZTogVGVtcGxhdGU8TT4pOiBUZW1wbGF0ZU9rPE0+IHtcbiAgaWYgKHRlbXBsYXRlLnJlc3VsdCA9PT0gJ2Vycm9yJykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBDb21waWxlIEVycm9yOiAke3RlbXBsYXRlLnByb2JsZW19IEAgJHt0ZW1wbGF0ZS5zcGFuLnN0YXJ0fS4uJHt0ZW1wbGF0ZS5zcGFuLmVuZH1gXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiB0ZW1wbGF0ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RIYW5kbGUoaGFuZGxlOiBIYW5kbGVSZXN1bHQpOiBudW1iZXIge1xuICBpZiAodHlwZW9mIGhhbmRsZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gaGFuZGxlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBoYW5kbGUuaGFuZGxlO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc09rSGFuZGxlKGhhbmRsZTogSGFuZGxlUmVzdWx0KTogaGFuZGxlIGlzIE9rSGFuZGxlIHtcbiAgcmV0dXJuIHR5cGVvZiBoYW5kbGUgPT09ICdudW1iZXInO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNFcnJIYW5kbGUoaGFuZGxlOiBIYW5kbGVSZXN1bHQpOiBoYW5kbGUgaXMgRXJySGFuZGxlIHtcbiAgcmV0dXJuIHR5cGVvZiBoYW5kbGUgPT09ICdudW1iZXInO1xufVxuIiwiaW1wb3J0IHsgREVCVUcgfSBmcm9tICdAZ2xpbW1lci9lbnYnO1xuXG5sZXQgZGVidWdUb1N0cmluZzogdW5kZWZpbmVkIHwgKCh2YWx1ZTogdW5rbm93bikgPT4gc3RyaW5nKTtcblxuaWYgKERFQlVHKSB7XG4gIGxldCBnZXRGdW5jdGlvbk5hbWUgPSAoZm46IEZ1bmN0aW9uKSA9PiB7XG4gICAgbGV0IGZ1bmN0aW9uTmFtZSA9IGZuLm5hbWU7XG5cbiAgICBpZiAoZnVuY3Rpb25OYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGxldCBtYXRjaCA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGZuKS5tYXRjaCgvZnVuY3Rpb24gKFxcdyspXFxzKlxcKC8pO1xuXG4gICAgICBmdW5jdGlvbk5hbWUgPSAobWF0Y2ggJiYgbWF0Y2hbMV0pIHx8ICcnO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbk5hbWUucmVwbGFjZSgvXmJvdW5kIC8sICcnKTtcbiAgfTtcblxuICBsZXQgZ2V0T2JqZWN0TmFtZSA9IChvYmo6IG9iamVjdCkgPT4ge1xuICAgIGxldCBuYW1lO1xuICAgIGxldCBjbGFzc05hbWU7XG5cbiAgICBpZiAob2JqLmNvbnN0cnVjdG9yICYmIG9iai5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0KSB7XG4gICAgICBjbGFzc05hbWUgPSBnZXRGdW5jdGlvbk5hbWUob2JqLmNvbnN0cnVjdG9yKTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICAndG9TdHJpbmcnIGluIG9iaiAmJlxuICAgICAgb2JqLnRvU3RyaW5nICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nICYmXG4gICAgICBvYmoudG9TdHJpbmcgIT09IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZ1xuICAgICkge1xuICAgICAgbmFtZSA9IG9iai50b1N0cmluZygpO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBjbGFzcyBoYXMgYSBkZWNlbnQgbG9va2luZyBuYW1lLCBhbmQgdGhlIGB0b1N0cmluZ2AgaXMgb25lIG9mIHRoZVxuICAgIC8vIGRlZmF1bHQgRW1iZXIgdG9TdHJpbmdzLCByZXBsYWNlIHRoZSBjb25zdHJ1Y3RvciBwb3J0aW9uIG9mIHRoZSB0b1N0cmluZ1xuICAgIC8vIHdpdGggdGhlIGNsYXNzIG5hbWUuIFdlIGNoZWNrIHRoZSBsZW5ndGggb2YgdGhlIGNsYXNzIG5hbWUgdG8gcHJldmVudCBkb2luZ1xuICAgIC8vIHRoaXMgd2hlbiB0aGUgdmFsdWUgaXMgbWluaWZpZWQuXG4gICAgaWYgKFxuICAgICAgbmFtZSAmJlxuICAgICAgbmFtZS5tYXRjaCgvPC4qOmVtYmVyXFxkKz4vKSAmJlxuICAgICAgY2xhc3NOYW1lICYmXG4gICAgICBjbGFzc05hbWVbMF0gIT09ICdfJyAmJlxuICAgICAgY2xhc3NOYW1lLmxlbmd0aCA+IDIgJiZcbiAgICAgIGNsYXNzTmFtZSAhPT0gJ0NsYXNzJ1xuICAgICkge1xuICAgICAgcmV0dXJuIG5hbWUucmVwbGFjZSgvPC4qOi8sIGA8JHtjbGFzc05hbWV9OmApO1xuICAgIH1cblxuICAgIHJldHVybiBuYW1lIHx8IGNsYXNzTmFtZTtcbiAgfTtcblxuICBsZXQgZ2V0UHJpbWl0aXZlTmFtZSA9ICh2YWx1ZTogYW55KSA9PiB7XG4gICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gIH07XG5cbiAgZGVidWdUb1N0cmluZyA9ICh2YWx1ZTogdW5rbm93bikgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBnZXRGdW5jdGlvbk5hbWUodmFsdWUpIHx8IGAodW5rbm93biBmdW5jdGlvbilgO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGdldE9iamVjdE5hbWUodmFsdWUpIHx8IGAodW5rbm93biBvYmplY3QpYDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGdldFByaW1pdGl2ZU5hbWUodmFsdWUpO1xuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVidWdUb1N0cmluZztcbiIsImV4cG9ydCB7IEVNUFRZX0FSUkFZIH0gZnJvbSAnLi9saWIvYXJyYXktdXRpbHMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBhc3NlcnQsIGRlcHJlY2F0ZSB9IGZyb20gJy4vbGliL2Fzc2VydCc7XG5leHBvcnQgeyBkaWN0LCBEaWN0U2V0LCBpc0RpY3QsIGlzT2JqZWN0LCBTZXQsIFN0YWNrSW1wbCBhcyBTdGFjayB9IGZyb20gJy4vbGliL2NvbGxlY3Rpb25zJztcbmV4cG9ydCAqIGZyb20gJy4vbGliL2Rlc3Ryb3knO1xuZXhwb3J0ICogZnJvbSAnLi9saWIvZG9tJztcbmV4cG9ydCB7IGVuc3VyZUd1aWQsIEhhc0d1aWQsIGluaXRpYWxpemVHdWlkIH0gZnJvbSAnLi9saWIvZ3VpZCc7XG5leHBvcnQge1xuICBpc1NlcmlhbGl6YXRpb25GaXJzdE5vZGUsXG4gIFNFUklBTElaQVRJT05fRklSU1RfTk9ERV9TVFJJTkcsXG59IGZyb20gJy4vbGliL2lzLXNlcmlhbGl6YXRpb24tZmlyc3Qtbm9kZSc7XG5leHBvcnQgKiBmcm9tICcuL2xpYi9saWZldGltZXMnO1xuZXhwb3J0IHtcbiAgQ2xvbmVhYmxlTGlzdE5vZGUsXG4gIEVNUFRZX1NMSUNFLFxuICBMaW5rZWRMaXN0LFxuICBMaW5rZWRMaXN0Tm9kZSxcbiAgTGlzdE5vZGUsXG4gIExpc3RTbGljZSxcbiAgU2xpY2UsXG59IGZyb20gJy4vbGliL2xpc3QtdXRpbHMnO1xuZXhwb3J0IHsgYXNzaWduLCBmaWxsTnVsbHMsIHZhbHVlcyB9IGZyb20gJy4vbGliL29iamVjdC11dGlscyc7XG5leHBvcnQgKiBmcm9tICcuL2xpYi9wbGF0Zm9ybS11dGlscyc7XG5leHBvcnQgKiBmcm9tICcuL2xpYi9zdHJpbmcnO1xuZXhwb3J0ICogZnJvbSAnLi9saWIvaW1tZWRpYXRlJztcbmV4cG9ydCAqIGZyb20gJy4vbGliL3RlbXBsYXRlJztcblxuZXhwb3J0IHsgZGVmYXVsdCBhcyBkZWJ1Z1RvU3RyaW5nIH0gZnJvbSAnLi9saWIvZGVidWctdG8tc3RyaW5nJztcblxuZXhwb3J0IHR5cGUgRklYTUU8VCwgUyBleHRlbmRzIHN0cmluZz4gPSAoVCAmIFMpIHwgVDtcblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydE5ldmVyKHZhbHVlOiBuZXZlciwgZGVzYyA9ICd1bmV4cGVjdGVkIHVucmVhY2hhYmxlIGJyYW5jaCcpOiB2b2lkIHtcbiAgY29uc29sZS5sb2coJ3VucmVhY2hhYmxlJywgdmFsdWUpO1xuICBjb25zb2xlLnRyYWNlKGAke2Rlc2N9IDo6ICR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfSAoJHt2YWx1ZX0pYCk7XG59XG4iXSwibmFtZXMiOlsiREVCVUciXSwibWFwcGluZ3MiOiI7O01BQWEsV0FBVyxHQUFVLE1BQU0sQ0FBTixNQUFBLENBQTNCLEVBQTJCOztFQ0FsQztFQUVBO0FBRUEsRUFBTSxTQUFBLFdBQUEsQ0FBQSxJQUFBLEVBQUEsR0FBQSxFQUE0QztFQUNoRDtFQUNBO0VBQ0E7RUFDQTtFQUVBLE1BQUksQ0FBSixJQUFBLEVBQVc7RUFDVCxVQUFNLElBQUEsS0FBQSxDQUFVLEdBQUcsSUFBbkIsbUJBQU0sQ0FBTjtFQUNEO0VBQ0Y7QUFFRCxFQUVNLFNBQUEsU0FBQSxDQUFBLElBQUEsRUFBZ0M7RUFDcEMsRUFBQSxPQUFPLENBQVAsSUFBQSxtQkFBQSxJQUFBO0VBQ0Q7O0VDbkJELElBQUksSUFBSSxHQUFSLENBQUE7QUFNQSxFQUFNLFNBQUEsY0FBQSxDQUFBLE1BQUEsRUFBd0M7RUFDNUMsU0FBUSxNQUFNLENBQU4sS0FBQSxHQUFlLEVBQXZCLElBQUE7RUFDRDtBQUVELEVBQU0sU0FBQSxVQUFBLENBQUEsTUFBQSxFQUFvQztFQUN4QyxTQUFPLE1BQU0sQ0FBTixLQUFBLElBQWdCLGNBQWMsQ0FBckMsTUFBcUMsQ0FBckM7RUFDRDs7Ozs7RUNI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
