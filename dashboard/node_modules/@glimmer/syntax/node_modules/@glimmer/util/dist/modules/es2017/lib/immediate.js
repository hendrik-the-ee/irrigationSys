import { exhausted } from './platform-utils';
let checkInt;

if (false
/* LOCAL_DEBUG */
) {
  // eslint-disable-next-line no-var,vars-on-top
  checkInt = (num, min = -2147483648, max = 2147483647) => {
    if (!isInt(num, min, max)) {
      throw new Error(`expected ${num} to be an integer between ${min} to ${max}`);
    }
  };
}
/**
 * Encodes a value that can be stored directly instead of being a handle.
 *
 * Immediates use the positive half of 32bits
 *
 * @param value - the value to be encoded.
 */


export function encodeImmediate(value) {
  if (typeof value === 'number') {
    if (false
    /* LOCAL_DEBUG */
    ) {
      checkInt(value, -1073741820
      /* MIN_INT */
      , 1073741823
      /* MAX_INT */
      );
    } // map -1 to -1073741820 onto 1073741828 to 2147483647
    // 1073741827 - (-1) == 1073741828
    // 1073741827 - (-1073741820) == 2147483647
    // positive it stays as is
    // 0 - 1073741823


    return value < 0 ? 1073741827
    /* NEGATIVE_BASE */
    - value : value;
  }

  if (value === false) {
    return 1073741824
    /* FALSE */
    ;
  }

  if (value === true) {
    return 1073741825
    /* TRUE */
    ;
  }

  if (value === null) {
    return 1073741826
    /* NULL */
    ;
  }

  if (value === undefined) {
    return 1073741827
    /* UNDEFINED */
    ;
  }

  return exhausted(value);
}
/**
 * Decodes an immediate into its value.
 *
 * @param value - the encoded immediate value
 */

export function decodeImmediate(value) {
  if (false
  /* LOCAL_DEBUG */
  ) {
    // expected value to be checked before this
    checkInt(value, 0
    /* MIN_IMMEDIATE */
    , 2147483647
    /* MAX_IMMEDIATE */
    );
  }

  if (value > 1073741823
  /* MAX_INT */
  ) {
      switch (value) {
        case 1073741824
        /* FALSE */
        :
          return false;

        case 1073741825
        /* TRUE */
        :
          return true;

        case 1073741826
        /* NULL */
        :
          return null;

        case 1073741827
        /* UNDEFINED */
        :
          return undefined;

        default:
          // map 1073741828 to 2147483647 to -1 to -1073741820
          // 1073741827 - 1073741828 == -1
          // 1073741827 - 2147483647 == -1073741820
          return 1073741827
          /* NEGATIVE_BASE */
          - value;
      }
    }

  return value;
}
/**
 * True if the number can be stored directly or false if it needs a handle.
 *
 * This is used on any number type to see if it can be directly encoded.
 */

export function isSmallInt(num) {
  return isInt(num, -1073741820
  /* MIN_INT */
  , 1073741823
  /* MAX_INT */
  );
}
/**
 * True if the encoded int32 operand or encoded stack int32 is a handle.
 */

export function isHandle(encoded) {
  if (false
  /* LOCAL_DEBUG */
  ) {
    // we expect to only use this method when we already know it is an int32
    // because it was encoded or read from the Int32Array buffer
    checkInt(encoded);
  }

  return encoded < 0;
}
/**
 * Encodes an index to an operand or stack handle.
 */

export function encodeHandle(index, maxIndex = 2147483647
/* MAX_INDEX */
, maxHandle = -1
/* MAX_HANDLE */
) {
  if (false
  /* LOCAL_DEBUG */
  ) {
    // expected the index to already be a positive int index from pushing the value
    checkInt(index, 0);
  }

  if (index > maxIndex) {
    throw new Error(`index ${index} overflowed range 0 to ${maxIndex}`);
  } // -1 - 0 == -1
  // -1 - 1073741823 == -1073741824
  // -1073741825 - 0 == -1073741825
  // -1073741825 - 1073741823 == -2147483648


  return maxHandle - index;
}
/**
 * Decodes the index from the specified operand or stack handle.
 */

export function decodeHandle(handle, maxHandle = -1
/* MAX_HANDLE */
) {
  if (false
  /* LOCAL_DEBUG */
  ) {
    // we expect to be decoding a encoded int32 operand or encoded int32 on the stack
    checkInt(handle, -2147483648
    /* MIN_HANDLE */
    , maxHandle);
  } // -1 - -1 == 0
  // -1 - -1073741824 == 1073741823
  // -1073741825 - -1073741825 == 0
  // -1073741825 - -2147483648 == 1073741823


  return maxHandle - handle;
}

function isInt(num, min, max) {
  // this is the same as Math.floor(num) === num
  // also NaN % 1 is NaN and Infinity % 1 is NaN so both should fail
  return num % 1 === 0 && num >= min && num <= max;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvbGliL2ltbWVkaWF0ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxTQUFTLFNBQVQsUUFBMEIsa0JBQTFCO0FBR0EsSUFBSSxRQUFKOztBQUVBO0FBQUE7QUFBQSxFQUFpQjtBQUNmO0FBQ0EsRUFBQSxRQUFRLEdBQUcsQ0FBQyxHQUFELEVBQWMsR0FBRyxHQUFHLENBQUMsVUFBckIsRUFBaUMsR0FBRyxHQUFHLFVBQXZDLEtBQXFEO0FBQzlELFFBQUksQ0FBQyxLQUFLLENBQUMsR0FBRCxFQUFNLEdBQU4sRUFBVyxHQUFYLENBQVYsRUFBMkI7QUFDekIsWUFBTSxJQUFJLEtBQUosQ0FBVSxZQUFZLEdBQUcsNkJBQTZCLEdBQUcsT0FBTyxHQUFHLEVBQW5FLENBQU47QUFDRDtBQUNGLEdBSkQ7QUFLRDtBQWdJRDs7Ozs7Ozs7O0FBT0EsT0FBTSxTQUFVLGVBQVYsQ0FBMEIsS0FBMUIsRUFBb0U7QUFDeEUsTUFBSSxPQUFPLEtBQVAsS0FBaUIsUUFBckIsRUFBK0I7QUFDN0I7QUFBQTtBQUFBLE1BQWlCO0FBQ2YsTUFBQSxRQUFTLENBQUMsS0FBRCxFQUFNLENBQUE7QUFBQTtBQUFOLFFBQU07QUFBQTtBQUFOLE9BQVQ7QUFDRCxLQUg0QixDQUk3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxXQUFPLEtBQUssR0FBRyxDQUFSLEdBQVk7QUFBQTtBQUFBLE1BQW1DLEtBQS9DLEdBQXVELEtBQTlEO0FBQ0Q7O0FBQ0QsTUFBSSxLQUFLLEtBQUssS0FBZCxFQUFxQjtBQUNuQixXQUFBO0FBQUE7QUFBQTtBQUNEOztBQUNELE1BQUksS0FBSyxLQUFLLElBQWQsRUFBb0I7QUFDbEIsV0FBQTtBQUFBO0FBQUE7QUFDRDs7QUFDRCxNQUFJLEtBQUssS0FBSyxJQUFkLEVBQW9CO0FBQ2xCLFdBQUE7QUFBQTtBQUFBO0FBQ0Q7O0FBQ0QsTUFBSSxLQUFLLEtBQUssU0FBZCxFQUF5QjtBQUN2QixXQUFBO0FBQUE7QUFBQTtBQUNEOztBQUNELFNBQU8sU0FBUyxDQUFDLEtBQUQsQ0FBaEI7QUFDRDtBQUVEOzs7Ozs7QUFLQSxPQUFNLFNBQVUsZUFBVixDQUEwQixLQUExQixFQUF1QztBQUMzQztBQUFBO0FBQUEsSUFBaUI7QUFDZjtBQUNBLElBQUEsUUFBUyxDQUFDLEtBQUQsRUFBTTtBQUFBO0FBQU4sTUFBTTtBQUFBO0FBQU4sS0FBVDtBQUNEOztBQUNELE1BQUksS0FBSyxHQUFBO0FBQUE7QUFBVCxJQUF3QztBQUN0QyxjQUFRLEtBQVI7QUFDRSxhQUFBO0FBQUE7QUFBQTtBQUNFLGlCQUFPLEtBQVA7O0FBQ0YsYUFBQTtBQUFBO0FBQUE7QUFDRSxpQkFBTyxJQUFQOztBQUNGLGFBQUE7QUFBQTtBQUFBO0FBQ0UsaUJBQU8sSUFBUDs7QUFDRixhQUFBO0FBQUE7QUFBQTtBQUNFLGlCQUFPLFNBQVA7O0FBQ0Y7QUFDRTtBQUNBO0FBQ0E7QUFDQSxpQkFBTztBQUFBO0FBQUEsWUFBbUMsS0FBMUM7QUFiSjtBQWVEOztBQUNELFNBQU8sS0FBUDtBQUNEO0FBRUQ7Ozs7OztBQUtBLE9BQU0sU0FBVSxVQUFWLENBQXFCLEdBQXJCLEVBQWdDO0FBQ3BDLFNBQU8sS0FBSyxDQUFDLEdBQUQsRUFBSSxDQUFBO0FBQUE7QUFBSixJQUFJO0FBQUE7QUFBSixHQUFaO0FBQ0Q7QUFFRDs7OztBQUdBLE9BQU0sU0FBVSxRQUFWLENBQW1CLE9BQW5CLEVBQWtDO0FBQ3RDO0FBQUE7QUFBQSxJQUFpQjtBQUNmO0FBQ0E7QUFDQSxJQUFBLFFBQVMsQ0FBQyxPQUFELENBQVQ7QUFDRDs7QUFDRCxTQUFPLE9BQU8sR0FBRyxDQUFqQjtBQUNEO0FBRUQ7Ozs7QUFHQSxPQUFNLFNBQVUsWUFBVixDQUNKLEtBREksRUFFSixRQUFBLEdBQUE7QUFBQTtBQUZJLEVBR0osU0FBQSxHQUFBLENBQUE7QUFBQTtBQUhJLEVBRzBDO0FBRTlDO0FBQUE7QUFBQSxJQUFpQjtBQUNmO0FBQ0EsSUFBQSxRQUFTLENBQUMsS0FBRCxFQUFRLENBQVIsQ0FBVDtBQUNEOztBQUNELE1BQUksS0FBSyxHQUFHLFFBQVosRUFBc0I7QUFDcEIsVUFBTSxJQUFJLEtBQUosQ0FBVSxTQUFTLEtBQUssMEJBQTBCLFFBQVEsRUFBMUQsQ0FBTjtBQUNELEdBUjZDLENBUzlDO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFPLFNBQVMsR0FBRyxLQUFuQjtBQUNEO0FBRUQ7Ozs7QUFHQSxPQUFNLFNBQVUsWUFBVixDQUF1QixNQUF2QixFQUF1QyxTQUFBLEdBQUEsQ0FBQTtBQUFBO0FBQXZDLEVBQXFGO0FBQ3pGO0FBQUE7QUFBQSxJQUFpQjtBQUNmO0FBQ0EsSUFBQSxRQUFTLENBQUMsTUFBRCxFQUFPLENBQUE7QUFBQTtBQUFQLE1BQXFDLFNBQXJDLENBQVQ7QUFDRCxHQUp3RixDQUt6RjtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBTyxTQUFTLEdBQUcsTUFBbkI7QUFDRDs7QUFFRCxTQUFTLEtBQVQsQ0FBZSxHQUFmLEVBQTRCLEdBQTVCLEVBQXlDLEdBQXpDLEVBQW9EO0FBQ2xEO0FBQ0E7QUFDQSxTQUFPLEdBQUcsR0FBRyxDQUFOLEtBQVksQ0FBWixJQUFpQixHQUFHLElBQUksR0FBeEIsSUFBK0IsR0FBRyxJQUFJLEdBQTdDO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBleGhhdXN0ZWQgfSBmcm9tICcuL3BsYXRmb3JtLXV0aWxzJztcbmltcG9ydCB7IExPQ0FMX0RFQlVHIH0gZnJvbSAnQGdsaW1tZXIvbG9jYWwtZGVidWctZmxhZ3MnO1xuXG5sZXQgY2hlY2tJbnQ6IHVuZGVmaW5lZCB8ICgobnVtOiBudW1iZXIsIG1pbj86IG51bWJlciwgbWF4PzogbnVtYmVyKSA9PiB2b2lkKTtcblxuaWYgKExPQ0FMX0RFQlVHKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby12YXIsdmFycy1vbi10b3BcbiAgY2hlY2tJbnQgPSAobnVtOiBudW1iZXIsIG1pbiA9IC0yMTQ3NDgzNjQ4LCBtYXggPSAyMTQ3NDgzNjQ3KSA9PiB7XG4gICAgaWYgKCFpc0ludChudW0sIG1pbiwgbWF4KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCAke251bX0gdG8gYmUgYW4gaW50ZWdlciBiZXR3ZWVuICR7bWlufSB0byAke21heH1gKTtcbiAgICB9XG4gIH07XG59XG5cbi8qXG5FbmNvZGluZyBub3Rlc1xuXG5maXJzdFxuMiBiaXRzICAgIHN0YXJ0ICAgICAgICBlbmRcbjAgMSAgICAgICAxMDczNzQxODI0ICAgMjE0NzQ4MzY0NyAgIGRpcmVjdCBuZWdhdGl2ZSBvciBib29sZWFuIG9yIG51bGwgb3IgdW5kZWZpbmVkXG4wIDAgICAgICAgMCAgICAgICAgICAgIDEwNzM3NDE4MjMgICBkaXJlY3QgcG9zaXRpdmVcbjEgMSAgICAgICAtMSAgICAgICAgICAgLTEwNzM3NDE4MjQgIHN0cmluZyBpbmRleFxuMSAwICAgICAgIC0xMDczNzQxODI1ICAtMjE0NzQ4MzY0OCAgbnVtYmVyIGluZGV4XG5cblNpbmNlIGZpcnN0IGJpdCBpcyB0aGUgc2lnbiBiaXQgdGhlblxuXG5lbmNvZGVkID49IDAgIGlzIGFsbCBkaXJlY3RseSBlbmNvZGVkIHZhbHVlc1xuZW5jb2RlZCA8IDAgIGlzIGFsbCBpbmRpcmVjdCBlbmNvZGVkIHZhbHVlcyAoZW5jb2RlZCBpbmRleGVzKVxuXG5Gb3IgZGlyZWN0bHkgZW5jb2RlZCB2YWx1ZXNcbmVuY29kZWQgICAgICBkZWNvZGVkXG4wICAgICAgICAgICAgMFxuLi4uICAgICAgICAgIC4uLlxuMTA3Mzc0MTgyMyAgIDEwNzM3NDE4MjNcbjEwNzM3NDE4MjQgICBmYWxzZVxuMTA3Mzc0MTgyNSAgIHRydWVcbjEwNzM3NDE4MjYgICBudWxsXG4xMDczNzQxODI3ICAgdW5kZWZpbmVkXG4xMDczNzQxODI4ICAgLTFcbi4uLiAgICAgICAgICAuLi5cbjIxNDc0ODM2NDcgICAtMTA3Mzc0MTgyMFxuXG5mb3Igc3RhY2sgaGFuZGxlc1xud2UgbWFwIGpzIGluZGV4IDAgdG8gMjE0NzQ4MzY0NyBvbnRvIC0xIHRvIC0yMTQ3NDgzNjQ4XG5cbmZvciBjb25zdGFudCBoYW5kbGVzXG53ZSBtYXAgc3RyaW5nIGluZGV4IDAgdG8gMTA3Mzc0MTgyMyBvbnRvIC0xIHRvIC0xMDczNzQxODI0XG53ZSBtYXAgbnVtYmVyIGluZGV4IDAgdG8gMTA3Mzc0MTgyMyBvbnRvIC0xMDczNzQxODI1IHRvIC0yMTQ3NDgzNjQ4XG4qL1xuXG4vKipcbiAqIEltbWVkaWF0ZXMgdXNlIHRoZSBwb3NpdGl2ZSBoYWxmIG9mIDMyIGJpdHMgMCB0aHJvdWdoIDIxNDc0ODM2NDcgKDB4N2ZmZmZmZmYpXG4gKiBsZWF2aW5nIHRoZSBuZWdhdGl2ZSBoYWxmIGZvciBoYW5kbGVzIC0xIHRocm91Z2ggLTIxNDc0ODM2NDguXG4gKi9cbmV4cG9ydCBjb25zdCBlbnVtIEltbWVkaWF0ZUNvbnN0YW50cyB7XG4gIC8qKlxuICAgKiAzMSBiaXRzIGNhbiBlbmNvZGUgMl4zMSB2YWx1ZXNcbiAgICovXG4gIElNTUVESUFURV9MRU5HVEggPSAyICoqIDMxLFxuXG4gIC8qKlxuICAgKiBNaW4gZW5jb2RlZCBpbW1lZGlhdGUgaXMgbWluIHBvc2l0aXZlXG4gICAqL1xuICBNSU5fSU1NRURJQVRFID0gMCxcblxuICAvKipcbiAgICogTWF4IGVuY29kZWQgaW1tZWRpYXRlIGlzIHRoZSBtYXggcG9zaXRpdmUgMzIgYml0IHNpZ25lZCBpbnRcbiAgICovXG4gIE1BWF9JTU1FRElBVEUgPSBJTU1FRElBVEVfTEVOR1RIIC0gMSxcblxuICAvKipcbiAgICogVGhlIGVuY29kaW5nIG9mIGZhbHNlLlxuICAgKiBGYWxzZSBpcyB0aGUgc3RhcnQgb2YgdGhlIHNlY29uZCBoYWxmIG9mIDMxIGJpdHNcbiAgICovXG4gIEZBTFNFID0gSU1NRURJQVRFX0xFTkdUSCAvIDIsXG5cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIGludCB0aGF0IGNhbiBiZSBkaXJlY3RseSBlbmNvZGVkIHZzIGEgaGFuZGxlLlxuICAgKlxuICAgKiBUaGUgbGFzdCBwb3NpdGl2ZSBpbnQgaXMganVzdCBiZWZvcmUgRkFMU0UuXG4gICAqL1xuICBNQVhfSU5UID0gRkFMU0UgLSAxLFxuXG4gIC8qKlxuICAgKiBUaGUgZW5jb2Rpbmcgb2YgdHJ1ZVxuICAgKi9cbiAgVFJVRSA9IEZBTFNFICsgMSxcblxuICAvKipcbiAgICogVGhlIGVuY29kaW5nIG9mIG51bGxcbiAgICovXG4gIE5VTEwgPSBUUlVFICsgMSxcblxuICAvKipcbiAgICogVGhlIGVuY29kaW5nIG9mIHVuZGVmaW5lZFxuICAgKi9cbiAgVU5ERUZJTkVEID0gTlVMTCArIDEsXG5cbiAgLyoqXG4gICAqIEVuY29kZWQgLTFcbiAgICpcbiAgICogRW5jb2RlZCBqdXN0IGFmdGVyIFVOREVGSU5FRFxuICAgKi9cbiAgTkVHQVRJVkVfT05FID0gVU5ERUZJTkVEICsgMSxcblxuICAvKipcbiAgICogVGhlIGJhc2UgdG8gc3Vic3RyYWN0IGEgbmVnYXRpdmUgZnJvbSB0byBkZWNvZGUgb3IgZW5jb2RlIGl0LlxuICAgKlxuICAgKiBORUdBVElWRV9PTkUgICAgICA9PSBORUdBVElWRV9CQVNFIC0gLTEgICAgICAgICAgICAgPT0gZW5jb2RlSW1tZWRpYXRlKC0xKVxuICAgKiBNQVhfSU1NRURJQVRFICAgICA9PSBORUdBVElWRV9CQVNFIC0gTUlOX0lOVCAgICAgICAgPT0gZW5jb2RlSW1tZWRpYXRlKE1JTl9JTlQpXG4gICAqIC0xICAgICAgICAgICAgICAgID09IE5FR0FUSVZFX0JBU0UgLSBORUdBVElWRV9PTkUgICA9PSBkZWNvZGVJbW1lZGlhdGUoTkVHQVRJVkVfT05FKVxuICAgKiBNSU5fSU5UICAgICAgICAgICA9PSBORUdBVElWRV9CQVNFIC0gTUFYX0lNTUVESUFURSAgPT0gZGVjb2RlSW1tZWRpYXRlKE1BWF9JTU1FRElBVEUpXG4gICAqL1xuICBORUdBVElWRV9CQVNFID0gTkVHQVRJVkVfT05FIC0gMSxcblxuICAvKipcbiAgICogVGhlIG1pbmltdW0gaW50IHRoYXQgY2FuIGJlIGRpcmVjdGx5IGVuY29kZWQgdnMgYSBoYW5kbGUuXG4gICAqL1xuICBNSU5fSU5UID0gTkVHQVRJVkVfQkFTRSAtIE1BWF9JTU1FRElBVEUsXG59XG5cbi8qKlxuICogVGhlIGNvbXBpbGVyIGNvbnN0YW50cyBkaXZpZGUgdGhlIGhhbmRsZXMgaW50byB0d28gaGFsdmVzIHN0cmluZ3MgYW5kIG51bWJlcnNcbiAqIHdoaWxlIG9uIHRoZSBzdGFjaywgdGhlcmUgaXMgb25seSBvbmUgYXJyYXkgb2YganMgdmFsdWVzLlxuICovXG5leHBvcnQgY29uc3QgZW51bSBIYW5kbGVDb25zdGFudHMge1xuICBIQU5ETEVfTEVOR1RIID0gMiAqKiAzMSxcbiAgTUFYX0lOREVYID0gSEFORExFX0xFTkdUSCAtIDEsXG4gIE1BWF9IQU5ETEUgPSAtMSxcbiAgTUlOX0hBTkRMRSA9IC0xIC0gTUFYX0lOREVYLFxuICBTVFJJTkdfSEFORExFX0xFTkdUSCA9IEhBTkRMRV9MRU5HVEggLyAyLFxuICBOVU1CRVJfSEFORExFX0xFTkdUSCA9IEhBTkRMRV9MRU5HVEggLSBTVFJJTkdfSEFORExFX0xFTkdUSCxcbiAgU1RSSU5HX01BWF9JTkRFWCA9IFNUUklOR19IQU5ETEVfTEVOR1RIIC0gMSxcbiAgTlVNQkVSX01BWF9JTkRFWCA9IE5VTUJFUl9IQU5ETEVfTEVOR1RIIC0gMSxcbiAgU1RSSU5HX01BWF9IQU5ETEUgPSBNQVhfSEFORExFLFxuICBTVFJJTkdfTUlOX0hBTkRMRSA9IFNUUklOR19NQVhfSEFORExFIC0gU1RSSU5HX01BWF9JTkRFWCxcbiAgTlVNQkVSX01BWF9IQU5ETEUgPSBTVFJJTkdfTUlOX0hBTkRMRSAtIDEsXG4gIE5VTUJFUl9NSU5fSEFORExFID0gTlVNQkVSX01BWF9IQU5ETEUgLSBOVU1CRVJfTUFYX0lOREVYLFxufVxuXG4vKipcbiAqIEVuY29kZXMgYSB2YWx1ZSB0aGF0IGNhbiBiZSBzdG9yZWQgZGlyZWN0bHkgaW5zdGVhZCBvZiBiZWluZyBhIGhhbmRsZS5cbiAqXG4gKiBJbW1lZGlhdGVzIHVzZSB0aGUgcG9zaXRpdmUgaGFsZiBvZiAzMmJpdHNcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSB0aGUgdmFsdWUgdG8gYmUgZW5jb2RlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZUltbWVkaWF0ZSh2YWx1ZTogbnVsbCB8IHVuZGVmaW5lZCB8IGJvb2xlYW4gfCBudW1iZXIpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAoTE9DQUxfREVCVUcpIHtcbiAgICAgIGNoZWNrSW50ISh2YWx1ZSwgSW1tZWRpYXRlQ29uc3RhbnRzLk1JTl9JTlQsIEltbWVkaWF0ZUNvbnN0YW50cy5NQVhfSU5UKTtcbiAgICB9XG4gICAgLy8gbWFwIC0xIHRvIC0xMDczNzQxODIwIG9udG8gMTA3Mzc0MTgyOCB0byAyMTQ3NDgzNjQ3XG4gICAgLy8gMTA3Mzc0MTgyNyAtICgtMSkgPT0gMTA3Mzc0MTgyOFxuICAgIC8vIDEwNzM3NDE4MjcgLSAoLTEwNzM3NDE4MjApID09IDIxNDc0ODM2NDdcbiAgICAvLyBwb3NpdGl2ZSBpdCBzdGF5cyBhcyBpc1xuICAgIC8vIDAgLSAxMDczNzQxODIzXG4gICAgcmV0dXJuIHZhbHVlIDwgMCA/IEltbWVkaWF0ZUNvbnN0YW50cy5ORUdBVElWRV9CQVNFIC0gdmFsdWUgOiB2YWx1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIEltbWVkaWF0ZUNvbnN0YW50cy5GQUxTRTtcbiAgfVxuICBpZiAodmFsdWUgPT09IHRydWUpIHtcbiAgICByZXR1cm4gSW1tZWRpYXRlQ29uc3RhbnRzLlRSVUU7XG4gIH1cbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIEltbWVkaWF0ZUNvbnN0YW50cy5OVUxMO1xuICB9XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIEltbWVkaWF0ZUNvbnN0YW50cy5VTkRFRklORUQ7XG4gIH1cbiAgcmV0dXJuIGV4aGF1c3RlZCh2YWx1ZSk7XG59XG5cbi8qKlxuICogRGVjb2RlcyBhbiBpbW1lZGlhdGUgaW50byBpdHMgdmFsdWUuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gdGhlIGVuY29kZWQgaW1tZWRpYXRlIHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVJbW1lZGlhdGUodmFsdWU6IG51bWJlcik6IG51bGwgfCB1bmRlZmluZWQgfCBib29sZWFuIHwgbnVtYmVyIHtcbiAgaWYgKExPQ0FMX0RFQlVHKSB7XG4gICAgLy8gZXhwZWN0ZWQgdmFsdWUgdG8gYmUgY2hlY2tlZCBiZWZvcmUgdGhpc1xuICAgIGNoZWNrSW50ISh2YWx1ZSwgSW1tZWRpYXRlQ29uc3RhbnRzLk1JTl9JTU1FRElBVEUsIEltbWVkaWF0ZUNvbnN0YW50cy5NQVhfSU1NRURJQVRFKTtcbiAgfVxuICBpZiAodmFsdWUgPiBJbW1lZGlhdGVDb25zdGFudHMuTUFYX0lOVCkge1xuICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgIGNhc2UgSW1tZWRpYXRlQ29uc3RhbnRzLkZBTFNFOlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICBjYXNlIEltbWVkaWF0ZUNvbnN0YW50cy5UUlVFOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgSW1tZWRpYXRlQ29uc3RhbnRzLk5VTEw6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBJbW1lZGlhdGVDb25zdGFudHMuVU5ERUZJTkVEOlxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gbWFwIDEwNzM3NDE4MjggdG8gMjE0NzQ4MzY0NyB0byAtMSB0byAtMTA3Mzc0MTgyMFxuICAgICAgICAvLyAxMDczNzQxODI3IC0gMTA3Mzc0MTgyOCA9PSAtMVxuICAgICAgICAvLyAxMDczNzQxODI3IC0gMjE0NzQ4MzY0NyA9PSAtMTA3Mzc0MTgyMFxuICAgICAgICByZXR1cm4gSW1tZWRpYXRlQ29uc3RhbnRzLk5FR0FUSVZFX0JBU0UgLSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIFRydWUgaWYgdGhlIG51bWJlciBjYW4gYmUgc3RvcmVkIGRpcmVjdGx5IG9yIGZhbHNlIGlmIGl0IG5lZWRzIGEgaGFuZGxlLlxuICpcbiAqIFRoaXMgaXMgdXNlZCBvbiBhbnkgbnVtYmVyIHR5cGUgdG8gc2VlIGlmIGl0IGNhbiBiZSBkaXJlY3RseSBlbmNvZGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTbWFsbEludChudW06IG51bWJlcikge1xuICByZXR1cm4gaXNJbnQobnVtLCBJbW1lZGlhdGVDb25zdGFudHMuTUlOX0lOVCwgSW1tZWRpYXRlQ29uc3RhbnRzLk1BWF9JTlQpO1xufVxuXG4vKipcbiAqIFRydWUgaWYgdGhlIGVuY29kZWQgaW50MzIgb3BlcmFuZCBvciBlbmNvZGVkIHN0YWNrIGludDMyIGlzIGEgaGFuZGxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNIYW5kbGUoZW5jb2RlZDogbnVtYmVyKSB7XG4gIGlmIChMT0NBTF9ERUJVRykge1xuICAgIC8vIHdlIGV4cGVjdCB0byBvbmx5IHVzZSB0aGlzIG1ldGhvZCB3aGVuIHdlIGFscmVhZHkga25vdyBpdCBpcyBhbiBpbnQzMlxuICAgIC8vIGJlY2F1c2UgaXQgd2FzIGVuY29kZWQgb3IgcmVhZCBmcm9tIHRoZSBJbnQzMkFycmF5IGJ1ZmZlclxuICAgIGNoZWNrSW50IShlbmNvZGVkKTtcbiAgfVxuICByZXR1cm4gZW5jb2RlZCA8IDA7XG59XG5cbi8qKlxuICogRW5jb2RlcyBhbiBpbmRleCB0byBhbiBvcGVyYW5kIG9yIHN0YWNrIGhhbmRsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZUhhbmRsZShcbiAgaW5kZXg6IG51bWJlcixcbiAgbWF4SW5kZXg6IG51bWJlciA9IEhhbmRsZUNvbnN0YW50cy5NQVhfSU5ERVgsXG4gIG1heEhhbmRsZTogbnVtYmVyID0gSGFuZGxlQ29uc3RhbnRzLk1BWF9IQU5ETEVcbikge1xuICBpZiAoTE9DQUxfREVCVUcpIHtcbiAgICAvLyBleHBlY3RlZCB0aGUgaW5kZXggdG8gYWxyZWFkeSBiZSBhIHBvc2l0aXZlIGludCBpbmRleCBmcm9tIHB1c2hpbmcgdGhlIHZhbHVlXG4gICAgY2hlY2tJbnQhKGluZGV4LCAwKTtcbiAgfVxuICBpZiAoaW5kZXggPiBtYXhJbmRleCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgaW5kZXggJHtpbmRleH0gb3ZlcmZsb3dlZCByYW5nZSAwIHRvICR7bWF4SW5kZXh9YCk7XG4gIH1cbiAgLy8gLTEgLSAwID09IC0xXG4gIC8vIC0xIC0gMTA3Mzc0MTgyMyA9PSAtMTA3Mzc0MTgyNFxuICAvLyAtMTA3Mzc0MTgyNSAtIDAgPT0gLTEwNzM3NDE4MjVcbiAgLy8gLTEwNzM3NDE4MjUgLSAxMDczNzQxODIzID09IC0yMTQ3NDgzNjQ4XG4gIHJldHVybiBtYXhIYW5kbGUgLSBpbmRleDtcbn1cblxuLyoqXG4gKiBEZWNvZGVzIHRoZSBpbmRleCBmcm9tIHRoZSBzcGVjaWZpZWQgb3BlcmFuZCBvciBzdGFjayBoYW5kbGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVIYW5kbGUoaGFuZGxlOiBudW1iZXIsIG1heEhhbmRsZTogbnVtYmVyID0gSGFuZGxlQ29uc3RhbnRzLk1BWF9IQU5ETEUpIHtcbiAgaWYgKExPQ0FMX0RFQlVHKSB7XG4gICAgLy8gd2UgZXhwZWN0IHRvIGJlIGRlY29kaW5nIGEgZW5jb2RlZCBpbnQzMiBvcGVyYW5kIG9yIGVuY29kZWQgaW50MzIgb24gdGhlIHN0YWNrXG4gICAgY2hlY2tJbnQhKGhhbmRsZSwgSGFuZGxlQ29uc3RhbnRzLk1JTl9IQU5ETEUsIG1heEhhbmRsZSk7XG4gIH1cbiAgLy8gLTEgLSAtMSA9PSAwXG4gIC8vIC0xIC0gLTEwNzM3NDE4MjQgPT0gMTA3Mzc0MTgyM1xuICAvLyAtMTA3Mzc0MTgyNSAtIC0xMDczNzQxODI1ID09IDBcbiAgLy8gLTEwNzM3NDE4MjUgLSAtMjE0NzQ4MzY0OCA9PSAxMDczNzQxODIzXG4gIHJldHVybiBtYXhIYW5kbGUgLSBoYW5kbGU7XG59XG5cbmZ1bmN0aW9uIGlzSW50KG51bTogbnVtYmVyLCBtaW46IG51bWJlciwgbWF4OiBudW1iZXIpOiBib29sZWFuIHtcbiAgLy8gdGhpcyBpcyB0aGUgc2FtZSBhcyBNYXRoLmZsb29yKG51bSkgPT09IG51bVxuICAvLyBhbHNvIE5hTiAlIDEgaXMgTmFOIGFuZCBJbmZpbml0eSAlIDEgaXMgTmFOIHNvIGJvdGggc2hvdWxkIGZhaWxcbiAgcmV0dXJuIG51bSAlIDEgPT09IDAgJiYgbnVtID49IG1pbiAmJiBudW0gPD0gbWF4O1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==