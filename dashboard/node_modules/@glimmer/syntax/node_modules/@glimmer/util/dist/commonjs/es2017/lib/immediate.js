"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.encodeImmediate = encodeImmediate;
exports.decodeImmediate = decodeImmediate;
exports.isSmallInt = isSmallInt;
exports.isHandle = isHandle;
exports.encodeHandle = encodeHandle;
exports.decodeHandle = decodeHandle;

var _platformUtils = require("./platform-utils");

let checkInt;

if (false
/* LOCAL_DEBUG */
) {
    // eslint-disable-next-line no-var,vars-on-top
    checkInt = (num, min = -2147483648, max = 2147483647) => {
      if (!isInt(num, min, max)) {
        throw new Error(`expected ${num} to be an integer between ${min} to ${max}`);
      }
    };
  }
/**
 * Encodes a value that can be stored directly instead of being a handle.
 *
 * Immediates use the positive half of 32bits
 *
 * @param value - the value to be encoded.
 */


function encodeImmediate(value) {
  if (typeof value === 'number') {
    if (false
    /* LOCAL_DEBUG */
    ) {
        checkInt(value, -1073741820
        /* MIN_INT */
        , 1073741823
        /* MAX_INT */
        );
      } // map -1 to -1073741820 onto 1073741828 to 2147483647
    // 1073741827 - (-1) == 1073741828
    // 1073741827 - (-1073741820) == 2147483647
    // positive it stays as is
    // 0 - 1073741823


    return value < 0 ? 1073741827
    /* NEGATIVE_BASE */
    - value : value;
  }

  if (value === false) {
    return 1073741824
    /* FALSE */
    ;
  }

  if (value === true) {
    return 1073741825
    /* TRUE */
    ;
  }

  if (value === null) {
    return 1073741826
    /* NULL */
    ;
  }

  if (value === undefined) {
    return 1073741827
    /* UNDEFINED */
    ;
  }

  return (0, _platformUtils.exhausted)(value);
}
/**
 * Decodes an immediate into its value.
 *
 * @param value - the encoded immediate value
 */


function decodeImmediate(value) {
  if (false
  /* LOCAL_DEBUG */
  ) {
      // expected value to be checked before this
      checkInt(value, 0
      /* MIN_IMMEDIATE */
      , 2147483647
      /* MAX_IMMEDIATE */
      );
    }

  if (value > 1073741823
  /* MAX_INT */
  ) {
      switch (value) {
        case 1073741824
        /* FALSE */
        :
          return false;

        case 1073741825
        /* TRUE */
        :
          return true;

        case 1073741826
        /* NULL */
        :
          return null;

        case 1073741827
        /* UNDEFINED */
        :
          return undefined;

        default:
          // map 1073741828 to 2147483647 to -1 to -1073741820
          // 1073741827 - 1073741828 == -1
          // 1073741827 - 2147483647 == -1073741820
          return 1073741827
          /* NEGATIVE_BASE */
          - value;
      }
    }

  return value;
}
/**
 * True if the number can be stored directly or false if it needs a handle.
 *
 * This is used on any number type to see if it can be directly encoded.
 */


function isSmallInt(num) {
  return isInt(num, -1073741820
  /* MIN_INT */
  , 1073741823
  /* MAX_INT */
  );
}
/**
 * True if the encoded int32 operand or encoded stack int32 is a handle.
 */


function isHandle(encoded) {
  if (false
  /* LOCAL_DEBUG */
  ) {
      // we expect to only use this method when we already know it is an int32
      // because it was encoded or read from the Int32Array buffer
      checkInt(encoded);
    }

  return encoded < 0;
}
/**
 * Encodes an index to an operand or stack handle.
 */


function encodeHandle(index, maxIndex = 2147483647
/* MAX_INDEX */
, maxHandle = -1
/* MAX_HANDLE */
) {
  if (false
  /* LOCAL_DEBUG */
  ) {
      // expected the index to already be a positive int index from pushing the value
      checkInt(index, 0);
    }

  if (index > maxIndex) {
    throw new Error(`index ${index} overflowed range 0 to ${maxIndex}`);
  } // -1 - 0 == -1
  // -1 - 1073741823 == -1073741824
  // -1073741825 - 0 == -1073741825
  // -1073741825 - 1073741823 == -2147483648


  return maxHandle - index;
}
/**
 * Decodes the index from the specified operand or stack handle.
 */


function decodeHandle(handle, maxHandle = -1
/* MAX_HANDLE */
) {
  if (false
  /* LOCAL_DEBUG */
  ) {
      // we expect to be decoding a encoded int32 operand or encoded int32 on the stack
      checkInt(handle, -2147483648
      /* MIN_HANDLE */
      , maxHandle);
    } // -1 - -1 == 0
  // -1 - -1073741824 == 1073741823
  // -1073741825 - -1073741825 == 0
  // -1073741825 - -2147483648 == 1073741823


  return maxHandle - handle;
}

function isInt(num, min, max) {
  // this is the same as Math.floor(num) === num
  // also NaN % 1 is NaN and Infinity % 1 is NaN so both should fail
  return num % 1 === 0 && num >= min && num <= max;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvbGliL2ltbWVkaWF0ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTs7QUFHQSxJQUFBLFFBQUE7O0FBRUEsSUFBQTtBQUFBO0FBQUEsRUFBaUI7QUFDZjtBQUNBLElBQUEsUUFBUSxHQUFHLENBQUEsR0FBQSxFQUFjLEdBQUcsR0FBRyxDQUFwQixVQUFBLEVBQWlDLEdBQUcsR0FBcEMsVUFBQSxLQUFxRDtBQUM5RCxVQUFJLENBQUMsS0FBSyxDQUFBLEdBQUEsRUFBQSxHQUFBLEVBQVYsR0FBVSxDQUFWLEVBQTJCO0FBQ3pCLGNBQU0sSUFBQSxLQUFBLENBQVUsWUFBWSxHQUFHLDZCQUE2QixHQUFHLE9BQU8sR0FBdEUsRUFBTSxDQUFOO0FBQ0Q7QUFISCxLQUFBO0FBS0Q7QUFnSUQ7Ozs7Ozs7OztBQU9NLFNBQUEsZUFBQSxDQUFBLEtBQUEsRUFBb0U7QUFDeEUsTUFBSSxPQUFBLEtBQUEsS0FBSixRQUFBLEVBQStCO0FBQzdCLFFBQUE7QUFBQTtBQUFBLE1BQWlCO0FBQ2YsUUFBQSxRQUFTLENBQUEsS0FBQSxFQUFNLENBQUE7QUFBQTtBQUFOLFVBQU07QUFBQTtBQUFOLFNBQVQ7QUFGMkIsT0FBQSxDQUk3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxXQUFPLEtBQUssR0FBTCxDQUFBLEdBQVk7QUFBQTtBQUFBLE1BQVosS0FBQSxHQUFQLEtBQUE7QUFDRDs7QUFDRCxNQUFJLEtBQUssS0FBVCxLQUFBLEVBQXFCO0FBQ25CLFdBQUE7QUFBQTtBQUFBO0FBQ0Q7O0FBQ0QsTUFBSSxLQUFLLEtBQVQsSUFBQSxFQUFvQjtBQUNsQixXQUFBO0FBQUE7QUFBQTtBQUNEOztBQUNELE1BQUksS0FBSyxLQUFULElBQUEsRUFBb0I7QUFDbEIsV0FBQTtBQUFBO0FBQUE7QUFDRDs7QUFDRCxNQUFJLEtBQUssS0FBVCxTQUFBLEVBQXlCO0FBQ3ZCLFdBQUE7QUFBQTtBQUFBO0FBQ0Q7O0FBQ0QsU0FBTyw4QkFBUCxLQUFPLENBQVA7QUFDRDtBQUVEOzs7Ozs7O0FBS00sU0FBQSxlQUFBLENBQUEsS0FBQSxFQUF1QztBQUMzQyxNQUFBO0FBQUE7QUFBQSxJQUFpQjtBQUNmO0FBQ0EsTUFBQSxRQUFTLENBQUEsS0FBQSxFQUFNO0FBQUE7QUFBTixRQUFNO0FBQUE7QUFBTixPQUFUO0FBQ0Q7O0FBQ0QsTUFBSSxLQUFLLEdBQUE7QUFBQTtBQUFULElBQXdDO0FBQ3RDLGNBQUEsS0FBQTtBQUNFLGFBQUE7QUFBQTtBQUFBO0FBQ0UsaUJBQUEsS0FBQTs7QUFDRixhQUFBO0FBQUE7QUFBQTtBQUNFLGlCQUFBLElBQUE7O0FBQ0YsYUFBQTtBQUFBO0FBQUE7QUFDRSxpQkFBQSxJQUFBOztBQUNGLGFBQUE7QUFBQTtBQUFBO0FBQ0UsaUJBQUEsU0FBQTs7QUFDRjtBQUNFO0FBQ0E7QUFDQTtBQUNBLGlCQUFPO0FBQUE7QUFBQSxZQUFQLEtBQUE7QUFiSjtBQWVEOztBQUNELFNBQUEsS0FBQTtBQUNEO0FBRUQ7Ozs7Ozs7QUFLTSxTQUFBLFVBQUEsQ0FBQSxHQUFBLEVBQWdDO0FBQ3BDLFNBQU8sS0FBSyxDQUFBLEdBQUEsRUFBSSxDQUFBO0FBQUE7QUFBSixJQUFJO0FBQUE7QUFBSixHQUFaO0FBQ0Q7QUFFRDs7Ozs7QUFHTSxTQUFBLFFBQUEsQ0FBQSxPQUFBLEVBQWtDO0FBQ3RDLE1BQUE7QUFBQTtBQUFBLElBQWlCO0FBQ2Y7QUFDQTtBQUNBLE1BQUEsUUFBUyxDQUFULE9BQVMsQ0FBVDtBQUNEOztBQUNELFNBQU8sT0FBTyxHQUFkLENBQUE7QUFDRDtBQUVEOzs7OztBQUdNLFNBQUEsWUFBQSxDQUFBLEtBQUEsRUFFSixRQUFBLEdBQUE7QUFBQTtBQUZJLEVBR0osU0FBQSxHQUFBLENBQUE7QUFBQTtBQUhJLEVBRzBDO0FBRTlDLE1BQUE7QUFBQTtBQUFBLElBQWlCO0FBQ2Y7QUFDQSxNQUFBLFFBQVMsQ0FBQSxLQUFBLEVBQVQsQ0FBUyxDQUFUO0FBQ0Q7O0FBQ0QsTUFBSSxLQUFLLEdBQVQsUUFBQSxFQUFzQjtBQUNwQixVQUFNLElBQUEsS0FBQSxDQUFVLFNBQVMsS0FBSywwQkFBMEIsUUFBeEQsRUFBTSxDQUFOO0FBUDRDLEdBQUEsQ0FTOUM7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFNBQU8sU0FBUyxHQUFoQixLQUFBO0FBQ0Q7QUFFRDs7Ozs7QUFHTSxTQUFBLFlBQUEsQ0FBQSxNQUFBLEVBQXVDLFNBQUEsR0FBQSxDQUFBO0FBQUE7QUFBdkMsRUFBcUY7QUFDekYsTUFBQTtBQUFBO0FBQUEsSUFBaUI7QUFDZjtBQUNBLE1BQUEsUUFBUyxDQUFBLE1BQUEsRUFBTyxDQUFBO0FBQUE7QUFBUCxRQUFULFNBQVMsQ0FBVDtBQUh1RixLQUFBLENBS3pGO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFPLFNBQVMsR0FBaEIsTUFBQTtBQUNEOztBQUVELFNBQUEsS0FBQSxDQUFBLEdBQUEsRUFBQSxHQUFBLEVBQUEsR0FBQSxFQUFvRDtBQUNsRDtBQUNBO0FBQ0EsU0FBTyxHQUFHLEdBQUgsQ0FBQSxLQUFBLENBQUEsSUFBaUIsR0FBRyxJQUFwQixHQUFBLElBQStCLEdBQUcsSUFBekMsR0FBQTtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZXhoYXVzdGVkIH0gZnJvbSAnLi9wbGF0Zm9ybS11dGlscyc7XG5pbXBvcnQgeyBMT0NBTF9ERUJVRyB9IGZyb20gJ0BnbGltbWVyL2xvY2FsLWRlYnVnLWZsYWdzJztcblxubGV0IGNoZWNrSW50OiB1bmRlZmluZWQgfCAoKG51bTogbnVtYmVyLCBtaW4/OiBudW1iZXIsIG1heD86IG51bWJlcikgPT4gdm9pZCk7XG5cbmlmIChMT0NBTF9ERUJVRykge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdmFyLHZhcnMtb24tdG9wXG4gIGNoZWNrSW50ID0gKG51bTogbnVtYmVyLCBtaW4gPSAtMjE0NzQ4MzY0OCwgbWF4ID0gMjE0NzQ4MzY0NykgPT4ge1xuICAgIGlmICghaXNJbnQobnVtLCBtaW4sIG1heCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgJHtudW19IHRvIGJlIGFuIGludGVnZXIgYmV0d2VlbiAke21pbn0gdG8gJHttYXh9YCk7XG4gICAgfVxuICB9O1xufVxuXG4vKlxuRW5jb2Rpbmcgbm90ZXNcblxuZmlyc3RcbjIgYml0cyAgICBzdGFydCAgICAgICAgZW5kXG4wIDEgICAgICAgMTA3Mzc0MTgyNCAgIDIxNDc0ODM2NDcgICBkaXJlY3QgbmVnYXRpdmUgb3IgYm9vbGVhbiBvciBudWxsIG9yIHVuZGVmaW5lZFxuMCAwICAgICAgIDAgICAgICAgICAgICAxMDczNzQxODIzICAgZGlyZWN0IHBvc2l0aXZlXG4xIDEgICAgICAgLTEgICAgICAgICAgIC0xMDczNzQxODI0ICBzdHJpbmcgaW5kZXhcbjEgMCAgICAgICAtMTA3Mzc0MTgyNSAgLTIxNDc0ODM2NDggIG51bWJlciBpbmRleFxuXG5TaW5jZSBmaXJzdCBiaXQgaXMgdGhlIHNpZ24gYml0IHRoZW5cblxuZW5jb2RlZCA+PSAwICBpcyBhbGwgZGlyZWN0bHkgZW5jb2RlZCB2YWx1ZXNcbmVuY29kZWQgPCAwICBpcyBhbGwgaW5kaXJlY3QgZW5jb2RlZCB2YWx1ZXMgKGVuY29kZWQgaW5kZXhlcylcblxuRm9yIGRpcmVjdGx5IGVuY29kZWQgdmFsdWVzXG5lbmNvZGVkICAgICAgZGVjb2RlZFxuMCAgICAgICAgICAgIDBcbi4uLiAgICAgICAgICAuLi5cbjEwNzM3NDE4MjMgICAxMDczNzQxODIzXG4xMDczNzQxODI0ICAgZmFsc2VcbjEwNzM3NDE4MjUgICB0cnVlXG4xMDczNzQxODI2ICAgbnVsbFxuMTA3Mzc0MTgyNyAgIHVuZGVmaW5lZFxuMTA3Mzc0MTgyOCAgIC0xXG4uLi4gICAgICAgICAgLi4uXG4yMTQ3NDgzNjQ3ICAgLTEwNzM3NDE4MjBcblxuZm9yIHN0YWNrIGhhbmRsZXNcbndlIG1hcCBqcyBpbmRleCAwIHRvIDIxNDc0ODM2NDcgb250byAtMSB0byAtMjE0NzQ4MzY0OFxuXG5mb3IgY29uc3RhbnQgaGFuZGxlc1xud2UgbWFwIHN0cmluZyBpbmRleCAwIHRvIDEwNzM3NDE4MjMgb250byAtMSB0byAtMTA3Mzc0MTgyNFxud2UgbWFwIG51bWJlciBpbmRleCAwIHRvIDEwNzM3NDE4MjMgb250byAtMTA3Mzc0MTgyNSB0byAtMjE0NzQ4MzY0OFxuKi9cblxuLyoqXG4gKiBJbW1lZGlhdGVzIHVzZSB0aGUgcG9zaXRpdmUgaGFsZiBvZiAzMiBiaXRzIDAgdGhyb3VnaCAyMTQ3NDgzNjQ3ICgweDdmZmZmZmZmKVxuICogbGVhdmluZyB0aGUgbmVnYXRpdmUgaGFsZiBmb3IgaGFuZGxlcyAtMSB0aHJvdWdoIC0yMTQ3NDgzNjQ4LlxuICovXG5leHBvcnQgY29uc3QgZW51bSBJbW1lZGlhdGVDb25zdGFudHMge1xuICAvKipcbiAgICogMzEgYml0cyBjYW4gZW5jb2RlIDJeMzEgdmFsdWVzXG4gICAqL1xuICBJTU1FRElBVEVfTEVOR1RIID0gMiAqKiAzMSxcblxuICAvKipcbiAgICogTWluIGVuY29kZWQgaW1tZWRpYXRlIGlzIG1pbiBwb3NpdGl2ZVxuICAgKi9cbiAgTUlOX0lNTUVESUFURSA9IDAsXG5cbiAgLyoqXG4gICAqIE1heCBlbmNvZGVkIGltbWVkaWF0ZSBpcyB0aGUgbWF4IHBvc2l0aXZlIDMyIGJpdCBzaWduZWQgaW50XG4gICAqL1xuICBNQVhfSU1NRURJQVRFID0gSU1NRURJQVRFX0xFTkdUSCAtIDEsXG5cbiAgLyoqXG4gICAqIFRoZSBlbmNvZGluZyBvZiBmYWxzZS5cbiAgICogRmFsc2UgaXMgdGhlIHN0YXJ0IG9mIHRoZSBzZWNvbmQgaGFsZiBvZiAzMSBiaXRzXG4gICAqL1xuICBGQUxTRSA9IElNTUVESUFURV9MRU5HVEggLyAyLFxuXG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBpbnQgdGhhdCBjYW4gYmUgZGlyZWN0bHkgZW5jb2RlZCB2cyBhIGhhbmRsZS5cbiAgICpcbiAgICogVGhlIGxhc3QgcG9zaXRpdmUgaW50IGlzIGp1c3QgYmVmb3JlIEZBTFNFLlxuICAgKi9cbiAgTUFYX0lOVCA9IEZBTFNFIC0gMSxcblxuICAvKipcbiAgICogVGhlIGVuY29kaW5nIG9mIHRydWVcbiAgICovXG4gIFRSVUUgPSBGQUxTRSArIDEsXG5cbiAgLyoqXG4gICAqIFRoZSBlbmNvZGluZyBvZiBudWxsXG4gICAqL1xuICBOVUxMID0gVFJVRSArIDEsXG5cbiAgLyoqXG4gICAqIFRoZSBlbmNvZGluZyBvZiB1bmRlZmluZWRcbiAgICovXG4gIFVOREVGSU5FRCA9IE5VTEwgKyAxLFxuXG4gIC8qKlxuICAgKiBFbmNvZGVkIC0xXG4gICAqXG4gICAqIEVuY29kZWQganVzdCBhZnRlciBVTkRFRklORURcbiAgICovXG4gIE5FR0FUSVZFX09ORSA9IFVOREVGSU5FRCArIDEsXG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIHRvIHN1YnN0cmFjdCBhIG5lZ2F0aXZlIGZyb20gdG8gZGVjb2RlIG9yIGVuY29kZSBpdC5cbiAgICpcbiAgICogTkVHQVRJVkVfT05FICAgICAgPT0gTkVHQVRJVkVfQkFTRSAtIC0xICAgICAgICAgICAgID09IGVuY29kZUltbWVkaWF0ZSgtMSlcbiAgICogTUFYX0lNTUVESUFURSAgICAgPT0gTkVHQVRJVkVfQkFTRSAtIE1JTl9JTlQgICAgICAgID09IGVuY29kZUltbWVkaWF0ZShNSU5fSU5UKVxuICAgKiAtMSAgICAgICAgICAgICAgICA9PSBORUdBVElWRV9CQVNFIC0gTkVHQVRJVkVfT05FICAgPT0gZGVjb2RlSW1tZWRpYXRlKE5FR0FUSVZFX09ORSlcbiAgICogTUlOX0lOVCAgICAgICAgICAgPT0gTkVHQVRJVkVfQkFTRSAtIE1BWF9JTU1FRElBVEUgID09IGRlY29kZUltbWVkaWF0ZShNQVhfSU1NRURJQVRFKVxuICAgKi9cbiAgTkVHQVRJVkVfQkFTRSA9IE5FR0FUSVZFX09ORSAtIDEsXG5cbiAgLyoqXG4gICAqIFRoZSBtaW5pbXVtIGludCB0aGF0IGNhbiBiZSBkaXJlY3RseSBlbmNvZGVkIHZzIGEgaGFuZGxlLlxuICAgKi9cbiAgTUlOX0lOVCA9IE5FR0FUSVZFX0JBU0UgLSBNQVhfSU1NRURJQVRFLFxufVxuXG4vKipcbiAqIFRoZSBjb21waWxlciBjb25zdGFudHMgZGl2aWRlIHRoZSBoYW5kbGVzIGludG8gdHdvIGhhbHZlcyBzdHJpbmdzIGFuZCBudW1iZXJzXG4gKiB3aGlsZSBvbiB0aGUgc3RhY2ssIHRoZXJlIGlzIG9ubHkgb25lIGFycmF5IG9mIGpzIHZhbHVlcy5cbiAqL1xuZXhwb3J0IGNvbnN0IGVudW0gSGFuZGxlQ29uc3RhbnRzIHtcbiAgSEFORExFX0xFTkdUSCA9IDIgKiogMzEsXG4gIE1BWF9JTkRFWCA9IEhBTkRMRV9MRU5HVEggLSAxLFxuICBNQVhfSEFORExFID0gLTEsXG4gIE1JTl9IQU5ETEUgPSAtMSAtIE1BWF9JTkRFWCxcbiAgU1RSSU5HX0hBTkRMRV9MRU5HVEggPSBIQU5ETEVfTEVOR1RIIC8gMixcbiAgTlVNQkVSX0hBTkRMRV9MRU5HVEggPSBIQU5ETEVfTEVOR1RIIC0gU1RSSU5HX0hBTkRMRV9MRU5HVEgsXG4gIFNUUklOR19NQVhfSU5ERVggPSBTVFJJTkdfSEFORExFX0xFTkdUSCAtIDEsXG4gIE5VTUJFUl9NQVhfSU5ERVggPSBOVU1CRVJfSEFORExFX0xFTkdUSCAtIDEsXG4gIFNUUklOR19NQVhfSEFORExFID0gTUFYX0hBTkRMRSxcbiAgU1RSSU5HX01JTl9IQU5ETEUgPSBTVFJJTkdfTUFYX0hBTkRMRSAtIFNUUklOR19NQVhfSU5ERVgsXG4gIE5VTUJFUl9NQVhfSEFORExFID0gU1RSSU5HX01JTl9IQU5ETEUgLSAxLFxuICBOVU1CRVJfTUlOX0hBTkRMRSA9IE5VTUJFUl9NQVhfSEFORExFIC0gTlVNQkVSX01BWF9JTkRFWCxcbn1cblxuLyoqXG4gKiBFbmNvZGVzIGEgdmFsdWUgdGhhdCBjYW4gYmUgc3RvcmVkIGRpcmVjdGx5IGluc3RlYWQgb2YgYmVpbmcgYSBoYW5kbGUuXG4gKlxuICogSW1tZWRpYXRlcyB1c2UgdGhlIHBvc2l0aXZlIGhhbGYgb2YgMzJiaXRzXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gdGhlIHZhbHVlIHRvIGJlIGVuY29kZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVJbW1lZGlhdGUodmFsdWU6IG51bGwgfCB1bmRlZmluZWQgfCBib29sZWFuIHwgbnVtYmVyKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKExPQ0FMX0RFQlVHKSB7XG4gICAgICBjaGVja0ludCEodmFsdWUsIEltbWVkaWF0ZUNvbnN0YW50cy5NSU5fSU5ULCBJbW1lZGlhdGVDb25zdGFudHMuTUFYX0lOVCk7XG4gICAgfVxuICAgIC8vIG1hcCAtMSB0byAtMTA3Mzc0MTgyMCBvbnRvIDEwNzM3NDE4MjggdG8gMjE0NzQ4MzY0N1xuICAgIC8vIDEwNzM3NDE4MjcgLSAoLTEpID09IDEwNzM3NDE4MjhcbiAgICAvLyAxMDczNzQxODI3IC0gKC0xMDczNzQxODIwKSA9PSAyMTQ3NDgzNjQ3XG4gICAgLy8gcG9zaXRpdmUgaXQgc3RheXMgYXMgaXNcbiAgICAvLyAwIC0gMTA3Mzc0MTgyM1xuICAgIHJldHVybiB2YWx1ZSA8IDAgPyBJbW1lZGlhdGVDb25zdGFudHMuTkVHQVRJVkVfQkFTRSAtIHZhbHVlIDogdmFsdWU7XG4gIH1cbiAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgIHJldHVybiBJbW1lZGlhdGVDb25zdGFudHMuRkFMU0U7XG4gIH1cbiAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIEltbWVkaWF0ZUNvbnN0YW50cy5UUlVFO1xuICB9XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBJbW1lZGlhdGVDb25zdGFudHMuTlVMTDtcbiAgfVxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBJbW1lZGlhdGVDb25zdGFudHMuVU5ERUZJTkVEO1xuICB9XG4gIHJldHVybiBleGhhdXN0ZWQodmFsdWUpO1xufVxuXG4vKipcbiAqIERlY29kZXMgYW4gaW1tZWRpYXRlIGludG8gaXRzIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIHRoZSBlbmNvZGVkIGltbWVkaWF0ZSB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlSW1tZWRpYXRlKHZhbHVlOiBudW1iZXIpOiBudWxsIHwgdW5kZWZpbmVkIHwgYm9vbGVhbiB8IG51bWJlciB7XG4gIGlmIChMT0NBTF9ERUJVRykge1xuICAgIC8vIGV4cGVjdGVkIHZhbHVlIHRvIGJlIGNoZWNrZWQgYmVmb3JlIHRoaXNcbiAgICBjaGVja0ludCEodmFsdWUsIEltbWVkaWF0ZUNvbnN0YW50cy5NSU5fSU1NRURJQVRFLCBJbW1lZGlhdGVDb25zdGFudHMuTUFYX0lNTUVESUFURSk7XG4gIH1cbiAgaWYgKHZhbHVlID4gSW1tZWRpYXRlQ29uc3RhbnRzLk1BWF9JTlQpIHtcbiAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICBjYXNlIEltbWVkaWF0ZUNvbnN0YW50cy5GQUxTRTpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgY2FzZSBJbW1lZGlhdGVDb25zdGFudHMuVFJVRTpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlIEltbWVkaWF0ZUNvbnN0YW50cy5OVUxMOlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNhc2UgSW1tZWRpYXRlQ29uc3RhbnRzLlVOREVGSU5FRDpcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIG1hcCAxMDczNzQxODI4IHRvIDIxNDc0ODM2NDcgdG8gLTEgdG8gLTEwNzM3NDE4MjBcbiAgICAgICAgLy8gMTA3Mzc0MTgyNyAtIDEwNzM3NDE4MjggPT0gLTFcbiAgICAgICAgLy8gMTA3Mzc0MTgyNyAtIDIxNDc0ODM2NDcgPT0gLTEwNzM3NDE4MjBcbiAgICAgICAgcmV0dXJuIEltbWVkaWF0ZUNvbnN0YW50cy5ORUdBVElWRV9CQVNFIC0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBUcnVlIGlmIHRoZSBudW1iZXIgY2FuIGJlIHN0b3JlZCBkaXJlY3RseSBvciBmYWxzZSBpZiBpdCBuZWVkcyBhIGhhbmRsZS5cbiAqXG4gKiBUaGlzIGlzIHVzZWQgb24gYW55IG51bWJlciB0eXBlIHRvIHNlZSBpZiBpdCBjYW4gYmUgZGlyZWN0bHkgZW5jb2RlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU21hbGxJbnQobnVtOiBudW1iZXIpIHtcbiAgcmV0dXJuIGlzSW50KG51bSwgSW1tZWRpYXRlQ29uc3RhbnRzLk1JTl9JTlQsIEltbWVkaWF0ZUNvbnN0YW50cy5NQVhfSU5UKTtcbn1cblxuLyoqXG4gKiBUcnVlIGlmIHRoZSBlbmNvZGVkIGludDMyIG9wZXJhbmQgb3IgZW5jb2RlZCBzdGFjayBpbnQzMiBpcyBhIGhhbmRsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzSGFuZGxlKGVuY29kZWQ6IG51bWJlcikge1xuICBpZiAoTE9DQUxfREVCVUcpIHtcbiAgICAvLyB3ZSBleHBlY3QgdG8gb25seSB1c2UgdGhpcyBtZXRob2Qgd2hlbiB3ZSBhbHJlYWR5IGtub3cgaXQgaXMgYW4gaW50MzJcbiAgICAvLyBiZWNhdXNlIGl0IHdhcyBlbmNvZGVkIG9yIHJlYWQgZnJvbSB0aGUgSW50MzJBcnJheSBidWZmZXJcbiAgICBjaGVja0ludCEoZW5jb2RlZCk7XG4gIH1cbiAgcmV0dXJuIGVuY29kZWQgPCAwO1xufVxuXG4vKipcbiAqIEVuY29kZXMgYW4gaW5kZXggdG8gYW4gb3BlcmFuZCBvciBzdGFjayBoYW5kbGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVIYW5kbGUoXG4gIGluZGV4OiBudW1iZXIsXG4gIG1heEluZGV4OiBudW1iZXIgPSBIYW5kbGVDb25zdGFudHMuTUFYX0lOREVYLFxuICBtYXhIYW5kbGU6IG51bWJlciA9IEhhbmRsZUNvbnN0YW50cy5NQVhfSEFORExFXG4pIHtcbiAgaWYgKExPQ0FMX0RFQlVHKSB7XG4gICAgLy8gZXhwZWN0ZWQgdGhlIGluZGV4IHRvIGFscmVhZHkgYmUgYSBwb3NpdGl2ZSBpbnQgaW5kZXggZnJvbSBwdXNoaW5nIHRoZSB2YWx1ZVxuICAgIGNoZWNrSW50IShpbmRleCwgMCk7XG4gIH1cbiAgaWYgKGluZGV4ID4gbWF4SW5kZXgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGluZGV4ICR7aW5kZXh9IG92ZXJmbG93ZWQgcmFuZ2UgMCB0byAke21heEluZGV4fWApO1xuICB9XG4gIC8vIC0xIC0gMCA9PSAtMVxuICAvLyAtMSAtIDEwNzM3NDE4MjMgPT0gLTEwNzM3NDE4MjRcbiAgLy8gLTEwNzM3NDE4MjUgLSAwID09IC0xMDczNzQxODI1XG4gIC8vIC0xMDczNzQxODI1IC0gMTA3Mzc0MTgyMyA9PSAtMjE0NzQ4MzY0OFxuICByZXR1cm4gbWF4SGFuZGxlIC0gaW5kZXg7XG59XG5cbi8qKlxuICogRGVjb2RlcyB0aGUgaW5kZXggZnJvbSB0aGUgc3BlY2lmaWVkIG9wZXJhbmQgb3Igc3RhY2sgaGFuZGxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlSGFuZGxlKGhhbmRsZTogbnVtYmVyLCBtYXhIYW5kbGU6IG51bWJlciA9IEhhbmRsZUNvbnN0YW50cy5NQVhfSEFORExFKSB7XG4gIGlmIChMT0NBTF9ERUJVRykge1xuICAgIC8vIHdlIGV4cGVjdCB0byBiZSBkZWNvZGluZyBhIGVuY29kZWQgaW50MzIgb3BlcmFuZCBvciBlbmNvZGVkIGludDMyIG9uIHRoZSBzdGFja1xuICAgIGNoZWNrSW50IShoYW5kbGUsIEhhbmRsZUNvbnN0YW50cy5NSU5fSEFORExFLCBtYXhIYW5kbGUpO1xuICB9XG4gIC8vIC0xIC0gLTEgPT0gMFxuICAvLyAtMSAtIC0xMDczNzQxODI0ID09IDEwNzM3NDE4MjNcbiAgLy8gLTEwNzM3NDE4MjUgLSAtMTA3Mzc0MTgyNSA9PSAwXG4gIC8vIC0xMDczNzQxODI1IC0gLTIxNDc0ODM2NDggPT0gMTA3Mzc0MTgyM1xuICByZXR1cm4gbWF4SGFuZGxlIC0gaGFuZGxlO1xufVxuXG5mdW5jdGlvbiBpc0ludChudW06IG51bWJlciwgbWluOiBudW1iZXIsIG1heDogbnVtYmVyKTogYm9vbGVhbiB7XG4gIC8vIHRoaXMgaXMgdGhlIHNhbWUgYXMgTWF0aC5mbG9vcihudW0pID09PSBudW1cbiAgLy8gYWxzbyBOYU4gJSAxIGlzIE5hTiBhbmQgSW5maW5pdHkgJSAxIGlzIE5hTiBzbyBib3RoIHNob3VsZCBmYWlsXG4gIHJldHVybiBudW0gJSAxID09PSAwICYmIG51bSA+PSBtaW4gJiYgbnVtIDw9IG1heDtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=